// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ADUpsDownsAnalysis.proto

#include "ADUpsDownsAnalysis.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace com {
namespace htsc {
namespace mdc {
namespace insight {
namespace model {
PROTOBUF_CONSTEXPR ADUpsDownsAnalysis::ADUpsDownsAnalysis(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.upsdownspartitiondetail_)*/{}
  , /*decltype(_impl_.htscsecurityid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.upsdownscount_)*/nullptr
  , /*decltype(_impl_.upsdownslimitcount_)*/nullptr
  , /*decltype(_impl_.mddate_)*/0
  , /*decltype(_impl_.mdtime_)*/0
  , /*decltype(_impl_.datatimestamp_)*/int64_t{0}
  , /*decltype(_impl_.securityidsource_)*/0
  , /*decltype(_impl_.securitytype_)*/0
  , /*decltype(_impl_.exchangedate_)*/0
  , /*decltype(_impl_.exchangetime_)*/0
  , /*decltype(_impl_.datamultiplepowerof10_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ADUpsDownsAnalysisDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ADUpsDownsAnalysisDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ADUpsDownsAnalysisDefaultTypeInternal() {}
  union {
    ADUpsDownsAnalysis _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ADUpsDownsAnalysisDefaultTypeInternal _ADUpsDownsAnalysis_default_instance_;
PROTOBUF_CONSTEXPR ADUpsDownsCount::ADUpsDownsCount(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ups_)*/0
  , /*decltype(_impl_.downs_)*/0
  , /*decltype(_impl_.equals_)*/0
  , /*decltype(_impl_.preups_)*/0
  , /*decltype(_impl_.predowns_)*/0
  , /*decltype(_impl_.preequals_)*/0
  , /*decltype(_impl_.upspercent_)*/0
  , /*decltype(_impl_.preupspercent_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ADUpsDownsCountDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ADUpsDownsCountDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ADUpsDownsCountDefaultTypeInternal() {}
  union {
    ADUpsDownsCount _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ADUpsDownsCountDefaultTypeInternal _ADUpsDownsCount_default_instance_;
PROTOBUF_CONSTEXPR ADUpsDownsLimitCount::ADUpsDownsLimitCount(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.noreachedlimitpx_)*/0
  , /*decltype(_impl_.uplimits_)*/0
  , /*decltype(_impl_.downlimits_)*/0
  , /*decltype(_impl_.prenoreachedlimitpx_)*/0
  , /*decltype(_impl_.preuplimits_)*/0
  , /*decltype(_impl_.predownlimits_)*/0
  , /*decltype(_impl_.preuplimitsaveragechangepercent_)*/0
  , /*decltype(_impl_.uplimitspercent_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ADUpsDownsLimitCountDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ADUpsDownsLimitCountDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ADUpsDownsLimitCountDefaultTypeInternal() {}
  union {
    ADUpsDownsLimitCount _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ADUpsDownsLimitCountDefaultTypeInternal _ADUpsDownsLimitCount_default_instance_;
PROTOBUF_CONSTEXPR ADUpsDownsPartitionDetail::ADUpsDownsPartitionDetail(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.numbers_)*/0
  , /*decltype(_impl_.partitionchangepercent_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ADUpsDownsPartitionDetailDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ADUpsDownsPartitionDetailDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ADUpsDownsPartitionDetailDefaultTypeInternal() {}
  union {
    ADUpsDownsPartitionDetail _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ADUpsDownsPartitionDetailDefaultTypeInternal _ADUpsDownsPartitionDetail_default_instance_;
}  // namespace model
}  // namespace insight
}  // namespace mdc
}  // namespace htsc
}  // namespace com
static ::_pb::Metadata file_level_metadata_ADUpsDownsAnalysis_2eproto[4];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_ADUpsDownsAnalysis_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_ADUpsDownsAnalysis_2eproto = nullptr;

const uint32_t TableStruct_ADUpsDownsAnalysis_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsAnalysis, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsAnalysis, _impl_.htscsecurityid_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsAnalysis, _impl_.mddate_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsAnalysis, _impl_.mdtime_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsAnalysis, _impl_.datatimestamp_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsAnalysis, _impl_.securityidsource_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsAnalysis, _impl_.securitytype_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsAnalysis, _impl_.upsdownscount_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsAnalysis, _impl_.upsdownslimitcount_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsAnalysis, _impl_.upsdownspartitiondetail_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsAnalysis, _impl_.exchangedate_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsAnalysis, _impl_.exchangetime_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsAnalysis, _impl_.datamultiplepowerof10_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsCount, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsCount, _impl_.ups_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsCount, _impl_.downs_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsCount, _impl_.equals_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsCount, _impl_.preups_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsCount, _impl_.predowns_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsCount, _impl_.preequals_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsCount, _impl_.upspercent_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsCount, _impl_.preupspercent_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsLimitCount, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsLimitCount, _impl_.noreachedlimitpx_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsLimitCount, _impl_.uplimits_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsLimitCount, _impl_.downlimits_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsLimitCount, _impl_.prenoreachedlimitpx_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsLimitCount, _impl_.preuplimits_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsLimitCount, _impl_.predownlimits_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsLimitCount, _impl_.preuplimitsaveragechangepercent_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsLimitCount, _impl_.uplimitspercent_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsPartitionDetail, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsPartitionDetail, _impl_.numbers_),
  PROTOBUF_FIELD_OFFSET(::com::htsc::mdc::insight::model::ADUpsDownsPartitionDetail, _impl_.partitionchangepercent_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::com::htsc::mdc::insight::model::ADUpsDownsAnalysis)},
  { 18, -1, -1, sizeof(::com::htsc::mdc::insight::model::ADUpsDownsCount)},
  { 32, -1, -1, sizeof(::com::htsc::mdc::insight::model::ADUpsDownsLimitCount)},
  { 46, -1, -1, sizeof(::com::htsc::mdc::insight::model::ADUpsDownsPartitionDetail)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::com::htsc::mdc::insight::model::_ADUpsDownsAnalysis_default_instance_._instance,
  &::com::htsc::mdc::insight::model::_ADUpsDownsCount_default_instance_._instance,
  &::com::htsc::mdc::insight::model::_ADUpsDownsLimitCount_default_instance_._instance,
  &::com::htsc::mdc::insight::model::_ADUpsDownsPartitionDetail_default_instance_._instance,
};

const char descriptor_table_protodef_ADUpsDownsAnalysis_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\030ADUpsDownsAnalysis.proto\022\032com.htsc.mdc"
  ".insight.model\032\023ESecurityType.proto\032\027ESe"
  "curityIDSource.proto\"\222\004\n\022ADUpsDownsAnaly"
  "sis\022\026\n\016HTSCSecurityID\030\001 \001(\t\022\016\n\006MDDate\030\002 "
  "\001(\005\022\016\n\006MDTime\030\003 \001(\005\022\025\n\rDataTimestamp\030\004 \001"
  "(\003\022\?\n\020securityIDSource\030\005 \001(\0162%.com.htsc."
  "mdc.model.ESecurityIDSource\0227\n\014securityT"
  "ype\030\006 \001(\0162!.com.htsc.mdc.model.ESecurity"
  "Type\022B\n\rUpsDownsCount\030\007 \001(\0132+.com.htsc.m"
  "dc.insight.model.ADUpsDownsCount\022L\n\022UpsD"
  "ownsLimitCount\030\010 \001(\01320.com.htsc.mdc.insi"
  "ght.model.ADUpsDownsLimitCount\022V\n\027UpsDow"
  "nsPartitionDetail\030\t \003(\01325.com.htsc.mdc.i"
  "nsight.model.ADUpsDownsPartitionDetail\022\024"
  "\n\014ExchangeDate\030\n \001(\005\022\024\n\014ExchangeTime\030\013 \001"
  "(\005\022\035\n\025DataMultiplePowerOf10\030\014 \001(\005\"\235\001\n\017AD"
  "UpsDownsCount\022\013\n\003Ups\030\001 \001(\005\022\r\n\005Downs\030\002 \001("
  "\005\022\016\n\006Equals\030\003 \001(\005\022\016\n\006PreUps\030\004 \001(\005\022\020\n\010Pre"
  "Downs\030\005 \001(\005\022\021\n\tPreEquals\030\006 \001(\005\022\022\n\nUpsPer"
  "cent\030\007 \001(\001\022\025\n\rPreUpsPercent\030\010 \001(\001\"\341\001\n\024AD"
  "UpsDownsLimitCount\022\030\n\020NoReachedLimitPx\030\001"
  " \001(\005\022\020\n\010UpLimits\030\002 \001(\005\022\022\n\nDownLimits\030\003 \001"
  "(\005\022\033\n\023PreNoReachedLimitPx\030\004 \001(\005\022\023\n\013PreUp"
  "Limits\030\005 \001(\005\022\025\n\rPreDownLimits\030\006 \001(\005\022\'\n\037P"
  "reUpLimitsAverageChangePercent\030\007 \001(\001\022\027\n\017"
  "UpLimitsPercent\030\010 \001(\001\"L\n\031ADUpsDownsParti"
  "tionDetail\022\017\n\007Numbers\030\001 \001(\005\022\036\n\026Partition"
  "ChangePercent\030\002 \001(\005B;\n\032com.htsc.mdc.insi"
  "ght.modelB\030ADUpsDownsAnalysisProtosH\001\240\001\001"
  "b\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_ADUpsDownsAnalysis_2eproto_deps[2] = {
  &::descriptor_table_ESecurityIDSource_2eproto,
  &::descriptor_table_ESecurityType_2eproto,
};
static ::_pbi::once_flag descriptor_table_ADUpsDownsAnalysis_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_ADUpsDownsAnalysis_2eproto = {
    false, false, 1168, descriptor_table_protodef_ADUpsDownsAnalysis_2eproto,
    "ADUpsDownsAnalysis.proto",
    &descriptor_table_ADUpsDownsAnalysis_2eproto_once, descriptor_table_ADUpsDownsAnalysis_2eproto_deps, 2, 4,
    schemas, file_default_instances, TableStruct_ADUpsDownsAnalysis_2eproto::offsets,
    file_level_metadata_ADUpsDownsAnalysis_2eproto, file_level_enum_descriptors_ADUpsDownsAnalysis_2eproto,
    file_level_service_descriptors_ADUpsDownsAnalysis_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_ADUpsDownsAnalysis_2eproto_getter() {
  return &descriptor_table_ADUpsDownsAnalysis_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_ADUpsDownsAnalysis_2eproto(&descriptor_table_ADUpsDownsAnalysis_2eproto);
namespace com {
namespace htsc {
namespace mdc {
namespace insight {
namespace model {

// ===================================================================

class ADUpsDownsAnalysis::_Internal {
 public:
  static const ::com::htsc::mdc::insight::model::ADUpsDownsCount& upsdownscount(const ADUpsDownsAnalysis* msg);
  static const ::com::htsc::mdc::insight::model::ADUpsDownsLimitCount& upsdownslimitcount(const ADUpsDownsAnalysis* msg);
};

const ::com::htsc::mdc::insight::model::ADUpsDownsCount&
ADUpsDownsAnalysis::_Internal::upsdownscount(const ADUpsDownsAnalysis* msg) {
  return *msg->_impl_.upsdownscount_;
}
const ::com::htsc::mdc::insight::model::ADUpsDownsLimitCount&
ADUpsDownsAnalysis::_Internal::upsdownslimitcount(const ADUpsDownsAnalysis* msg) {
  return *msg->_impl_.upsdownslimitcount_;
}
ADUpsDownsAnalysis::ADUpsDownsAnalysis(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:com.htsc.mdc.insight.model.ADUpsDownsAnalysis)
}
ADUpsDownsAnalysis::ADUpsDownsAnalysis(const ADUpsDownsAnalysis& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ADUpsDownsAnalysis* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.upsdownspartitiondetail_){from._impl_.upsdownspartitiondetail_}
    , decltype(_impl_.htscsecurityid_){}
    , decltype(_impl_.upsdownscount_){nullptr}
    , decltype(_impl_.upsdownslimitcount_){nullptr}
    , decltype(_impl_.mddate_){}
    , decltype(_impl_.mdtime_){}
    , decltype(_impl_.datatimestamp_){}
    , decltype(_impl_.securityidsource_){}
    , decltype(_impl_.securitytype_){}
    , decltype(_impl_.exchangedate_){}
    , decltype(_impl_.exchangetime_){}
    , decltype(_impl_.datamultiplepowerof10_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.htscsecurityid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.htscsecurityid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_htscsecurityid().empty()) {
    _this->_impl_.htscsecurityid_.Set(from._internal_htscsecurityid(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_upsdownscount()) {
    _this->_impl_.upsdownscount_ = new ::com::htsc::mdc::insight::model::ADUpsDownsCount(*from._impl_.upsdownscount_);
  }
  if (from._internal_has_upsdownslimitcount()) {
    _this->_impl_.upsdownslimitcount_ = new ::com::htsc::mdc::insight::model::ADUpsDownsLimitCount(*from._impl_.upsdownslimitcount_);
  }
  ::memcpy(&_impl_.mddate_, &from._impl_.mddate_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.datamultiplepowerof10_) -
    reinterpret_cast<char*>(&_impl_.mddate_)) + sizeof(_impl_.datamultiplepowerof10_));
  // @@protoc_insertion_point(copy_constructor:com.htsc.mdc.insight.model.ADUpsDownsAnalysis)
}

inline void ADUpsDownsAnalysis::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.upsdownspartitiondetail_){arena}
    , decltype(_impl_.htscsecurityid_){}
    , decltype(_impl_.upsdownscount_){nullptr}
    , decltype(_impl_.upsdownslimitcount_){nullptr}
    , decltype(_impl_.mddate_){0}
    , decltype(_impl_.mdtime_){0}
    , decltype(_impl_.datatimestamp_){int64_t{0}}
    , decltype(_impl_.securityidsource_){0}
    , decltype(_impl_.securitytype_){0}
    , decltype(_impl_.exchangedate_){0}
    , decltype(_impl_.exchangetime_){0}
    , decltype(_impl_.datamultiplepowerof10_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.htscsecurityid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.htscsecurityid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ADUpsDownsAnalysis::~ADUpsDownsAnalysis() {
  // @@protoc_insertion_point(destructor:com.htsc.mdc.insight.model.ADUpsDownsAnalysis)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ADUpsDownsAnalysis::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.upsdownspartitiondetail_.~RepeatedPtrField();
  _impl_.htscsecurityid_.Destroy();
  if (this != internal_default_instance()) delete _impl_.upsdownscount_;
  if (this != internal_default_instance()) delete _impl_.upsdownslimitcount_;
}

void ADUpsDownsAnalysis::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ADUpsDownsAnalysis::Clear() {
// @@protoc_insertion_point(message_clear_start:com.htsc.mdc.insight.model.ADUpsDownsAnalysis)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.upsdownspartitiondetail_.Clear();
  _impl_.htscsecurityid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.upsdownscount_ != nullptr) {
    delete _impl_.upsdownscount_;
  }
  _impl_.upsdownscount_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.upsdownslimitcount_ != nullptr) {
    delete _impl_.upsdownslimitcount_;
  }
  _impl_.upsdownslimitcount_ = nullptr;
  ::memset(&_impl_.mddate_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.datamultiplepowerof10_) -
      reinterpret_cast<char*>(&_impl_.mddate_)) + sizeof(_impl_.datamultiplepowerof10_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ADUpsDownsAnalysis::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string HTSCSecurityID = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_htscsecurityid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "com.htsc.mdc.insight.model.ADUpsDownsAnalysis.HTSCSecurityID"));
        } else
          goto handle_unusual;
        continue;
      // int32 MDDate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.mddate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 MDTime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.mdtime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 DataTimestamp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.datatimestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .com.htsc.mdc.model.ESecurityIDSource securityIDSource = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_securityidsource(static_cast<::com::htsc::mdc::model::ESecurityIDSource>(val));
        } else
          goto handle_unusual;
        continue;
      // .com.htsc.mdc.model.ESecurityType securityType = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_securitytype(static_cast<::com::htsc::mdc::model::ESecurityType>(val));
        } else
          goto handle_unusual;
        continue;
      // .com.htsc.mdc.insight.model.ADUpsDownsCount UpsDownsCount = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_upsdownscount(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .com.htsc.mdc.insight.model.ADUpsDownsLimitCount UpsDownsLimitCount = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_upsdownslimitcount(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .com.htsc.mdc.insight.model.ADUpsDownsPartitionDetail UpsDownsPartitionDetail = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_upsdownspartitiondetail(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int32 ExchangeDate = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.exchangedate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 ExchangeTime = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.exchangetime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 DataMultiplePowerOf10 = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.datamultiplepowerof10_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ADUpsDownsAnalysis::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.htsc.mdc.insight.model.ADUpsDownsAnalysis)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string HTSCSecurityID = 1;
  if (!this->_internal_htscsecurityid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_htscsecurityid().data(), static_cast<int>(this->_internal_htscsecurityid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "com.htsc.mdc.insight.model.ADUpsDownsAnalysis.HTSCSecurityID");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_htscsecurityid(), target);
  }

  // int32 MDDate = 2;
  if (this->_internal_mddate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_mddate(), target);
  }

  // int32 MDTime = 3;
  if (this->_internal_mdtime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_mdtime(), target);
  }

  // int64 DataTimestamp = 4;
  if (this->_internal_datatimestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_datatimestamp(), target);
  }

  // .com.htsc.mdc.model.ESecurityIDSource securityIDSource = 5;
  if (this->_internal_securityidsource() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_securityidsource(), target);
  }

  // .com.htsc.mdc.model.ESecurityType securityType = 6;
  if (this->_internal_securitytype() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_securitytype(), target);
  }

  // .com.htsc.mdc.insight.model.ADUpsDownsCount UpsDownsCount = 7;
  if (this->_internal_has_upsdownscount()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::upsdownscount(this),
        _Internal::upsdownscount(this).GetCachedSize(), target, stream);
  }

  // .com.htsc.mdc.insight.model.ADUpsDownsLimitCount UpsDownsLimitCount = 8;
  if (this->_internal_has_upsdownslimitcount()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::upsdownslimitcount(this),
        _Internal::upsdownslimitcount(this).GetCachedSize(), target, stream);
  }

  // repeated .com.htsc.mdc.insight.model.ADUpsDownsPartitionDetail UpsDownsPartitionDetail = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_upsdownspartitiondetail_size()); i < n; i++) {
    const auto& repfield = this->_internal_upsdownspartitiondetail(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int32 ExchangeDate = 10;
  if (this->_internal_exchangedate() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_exchangedate(), target);
  }

  // int32 ExchangeTime = 11;
  if (this->_internal_exchangetime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_exchangetime(), target);
  }

  // int32 DataMultiplePowerOf10 = 12;
  if (this->_internal_datamultiplepowerof10() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_datamultiplepowerof10(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:com.htsc.mdc.insight.model.ADUpsDownsAnalysis)
  return target;
}

size_t ADUpsDownsAnalysis::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.htsc.mdc.insight.model.ADUpsDownsAnalysis)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .com.htsc.mdc.insight.model.ADUpsDownsPartitionDetail UpsDownsPartitionDetail = 9;
  total_size += 1UL * this->_internal_upsdownspartitiondetail_size();
  for (const auto& msg : this->_impl_.upsdownspartitiondetail_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string HTSCSecurityID = 1;
  if (!this->_internal_htscsecurityid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_htscsecurityid());
  }

  // .com.htsc.mdc.insight.model.ADUpsDownsCount UpsDownsCount = 7;
  if (this->_internal_has_upsdownscount()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.upsdownscount_);
  }

  // .com.htsc.mdc.insight.model.ADUpsDownsLimitCount UpsDownsLimitCount = 8;
  if (this->_internal_has_upsdownslimitcount()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.upsdownslimitcount_);
  }

  // int32 MDDate = 2;
  if (this->_internal_mddate() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mddate());
  }

  // int32 MDTime = 3;
  if (this->_internal_mdtime() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mdtime());
  }

  // int64 DataTimestamp = 4;
  if (this->_internal_datatimestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_datatimestamp());
  }

  // .com.htsc.mdc.model.ESecurityIDSource securityIDSource = 5;
  if (this->_internal_securityidsource() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_securityidsource());
  }

  // .com.htsc.mdc.model.ESecurityType securityType = 6;
  if (this->_internal_securitytype() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_securitytype());
  }

  // int32 ExchangeDate = 10;
  if (this->_internal_exchangedate() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_exchangedate());
  }

  // int32 ExchangeTime = 11;
  if (this->_internal_exchangetime() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_exchangetime());
  }

  // int32 DataMultiplePowerOf10 = 12;
  if (this->_internal_datamultiplepowerof10() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_datamultiplepowerof10());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ADUpsDownsAnalysis::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ADUpsDownsAnalysis::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ADUpsDownsAnalysis::GetClassData() const { return &_class_data_; }


void ADUpsDownsAnalysis::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ADUpsDownsAnalysis*>(&to_msg);
  auto& from = static_cast<const ADUpsDownsAnalysis&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:com.htsc.mdc.insight.model.ADUpsDownsAnalysis)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.upsdownspartitiondetail_.MergeFrom(from._impl_.upsdownspartitiondetail_);
  if (!from._internal_htscsecurityid().empty()) {
    _this->_internal_set_htscsecurityid(from._internal_htscsecurityid());
  }
  if (from._internal_has_upsdownscount()) {
    _this->_internal_mutable_upsdownscount()->::com::htsc::mdc::insight::model::ADUpsDownsCount::MergeFrom(
        from._internal_upsdownscount());
  }
  if (from._internal_has_upsdownslimitcount()) {
    _this->_internal_mutable_upsdownslimitcount()->::com::htsc::mdc::insight::model::ADUpsDownsLimitCount::MergeFrom(
        from._internal_upsdownslimitcount());
  }
  if (from._internal_mddate() != 0) {
    _this->_internal_set_mddate(from._internal_mddate());
  }
  if (from._internal_mdtime() != 0) {
    _this->_internal_set_mdtime(from._internal_mdtime());
  }
  if (from._internal_datatimestamp() != 0) {
    _this->_internal_set_datatimestamp(from._internal_datatimestamp());
  }
  if (from._internal_securityidsource() != 0) {
    _this->_internal_set_securityidsource(from._internal_securityidsource());
  }
  if (from._internal_securitytype() != 0) {
    _this->_internal_set_securitytype(from._internal_securitytype());
  }
  if (from._internal_exchangedate() != 0) {
    _this->_internal_set_exchangedate(from._internal_exchangedate());
  }
  if (from._internal_exchangetime() != 0) {
    _this->_internal_set_exchangetime(from._internal_exchangetime());
  }
  if (from._internal_datamultiplepowerof10() != 0) {
    _this->_internal_set_datamultiplepowerof10(from._internal_datamultiplepowerof10());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ADUpsDownsAnalysis::CopyFrom(const ADUpsDownsAnalysis& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.htsc.mdc.insight.model.ADUpsDownsAnalysis)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ADUpsDownsAnalysis::IsInitialized() const {
  return true;
}

void ADUpsDownsAnalysis::InternalSwap(ADUpsDownsAnalysis* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.upsdownspartitiondetail_.InternalSwap(&other->_impl_.upsdownspartitiondetail_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.htscsecurityid_, lhs_arena,
      &other->_impl_.htscsecurityid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ADUpsDownsAnalysis, _impl_.datamultiplepowerof10_)
      + sizeof(ADUpsDownsAnalysis::_impl_.datamultiplepowerof10_)
      - PROTOBUF_FIELD_OFFSET(ADUpsDownsAnalysis, _impl_.upsdownscount_)>(
          reinterpret_cast<char*>(&_impl_.upsdownscount_),
          reinterpret_cast<char*>(&other->_impl_.upsdownscount_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ADUpsDownsAnalysis::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ADUpsDownsAnalysis_2eproto_getter, &descriptor_table_ADUpsDownsAnalysis_2eproto_once,
      file_level_metadata_ADUpsDownsAnalysis_2eproto[0]);
}

// ===================================================================

class ADUpsDownsCount::_Internal {
 public:
};

ADUpsDownsCount::ADUpsDownsCount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:com.htsc.mdc.insight.model.ADUpsDownsCount)
}
ADUpsDownsCount::ADUpsDownsCount(const ADUpsDownsCount& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ADUpsDownsCount* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ups_){}
    , decltype(_impl_.downs_){}
    , decltype(_impl_.equals_){}
    , decltype(_impl_.preups_){}
    , decltype(_impl_.predowns_){}
    , decltype(_impl_.preequals_){}
    , decltype(_impl_.upspercent_){}
    , decltype(_impl_.preupspercent_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.ups_, &from._impl_.ups_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.preupspercent_) -
    reinterpret_cast<char*>(&_impl_.ups_)) + sizeof(_impl_.preupspercent_));
  // @@protoc_insertion_point(copy_constructor:com.htsc.mdc.insight.model.ADUpsDownsCount)
}

inline void ADUpsDownsCount::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ups_){0}
    , decltype(_impl_.downs_){0}
    , decltype(_impl_.equals_){0}
    , decltype(_impl_.preups_){0}
    , decltype(_impl_.predowns_){0}
    , decltype(_impl_.preequals_){0}
    , decltype(_impl_.upspercent_){0}
    , decltype(_impl_.preupspercent_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ADUpsDownsCount::~ADUpsDownsCount() {
  // @@protoc_insertion_point(destructor:com.htsc.mdc.insight.model.ADUpsDownsCount)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ADUpsDownsCount::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ADUpsDownsCount::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ADUpsDownsCount::Clear() {
// @@protoc_insertion_point(message_clear_start:com.htsc.mdc.insight.model.ADUpsDownsCount)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.ups_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.preupspercent_) -
      reinterpret_cast<char*>(&_impl_.ups_)) + sizeof(_impl_.preupspercent_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ADUpsDownsCount::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 Ups = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.ups_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 Downs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.downs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 Equals = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.equals_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 PreUps = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.preups_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 PreDowns = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.predowns_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 PreEquals = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.preequals_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double UpsPercent = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _impl_.upspercent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double PreUpsPercent = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _impl_.preupspercent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ADUpsDownsCount::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.htsc.mdc.insight.model.ADUpsDownsCount)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 Ups = 1;
  if (this->_internal_ups() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_ups(), target);
  }

  // int32 Downs = 2;
  if (this->_internal_downs() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_downs(), target);
  }

  // int32 Equals = 3;
  if (this->_internal_equals() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_equals(), target);
  }

  // int32 PreUps = 4;
  if (this->_internal_preups() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_preups(), target);
  }

  // int32 PreDowns = 5;
  if (this->_internal_predowns() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_predowns(), target);
  }

  // int32 PreEquals = 6;
  if (this->_internal_preequals() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_preequals(), target);
  }

  // double UpsPercent = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_upspercent = this->_internal_upspercent();
  uint64_t raw_upspercent;
  memcpy(&raw_upspercent, &tmp_upspercent, sizeof(tmp_upspercent));
  if (raw_upspercent != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_upspercent(), target);
  }

  // double PreUpsPercent = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_preupspercent = this->_internal_preupspercent();
  uint64_t raw_preupspercent;
  memcpy(&raw_preupspercent, &tmp_preupspercent, sizeof(tmp_preupspercent));
  if (raw_preupspercent != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_preupspercent(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:com.htsc.mdc.insight.model.ADUpsDownsCount)
  return target;
}

size_t ADUpsDownsCount::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.htsc.mdc.insight.model.ADUpsDownsCount)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 Ups = 1;
  if (this->_internal_ups() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ups());
  }

  // int32 Downs = 2;
  if (this->_internal_downs() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_downs());
  }

  // int32 Equals = 3;
  if (this->_internal_equals() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_equals());
  }

  // int32 PreUps = 4;
  if (this->_internal_preups() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_preups());
  }

  // int32 PreDowns = 5;
  if (this->_internal_predowns() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_predowns());
  }

  // int32 PreEquals = 6;
  if (this->_internal_preequals() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_preequals());
  }

  // double UpsPercent = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_upspercent = this->_internal_upspercent();
  uint64_t raw_upspercent;
  memcpy(&raw_upspercent, &tmp_upspercent, sizeof(tmp_upspercent));
  if (raw_upspercent != 0) {
    total_size += 1 + 8;
  }

  // double PreUpsPercent = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_preupspercent = this->_internal_preupspercent();
  uint64_t raw_preupspercent;
  memcpy(&raw_preupspercent, &tmp_preupspercent, sizeof(tmp_preupspercent));
  if (raw_preupspercent != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ADUpsDownsCount::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ADUpsDownsCount::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ADUpsDownsCount::GetClassData() const { return &_class_data_; }


void ADUpsDownsCount::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ADUpsDownsCount*>(&to_msg);
  auto& from = static_cast<const ADUpsDownsCount&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:com.htsc.mdc.insight.model.ADUpsDownsCount)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_ups() != 0) {
    _this->_internal_set_ups(from._internal_ups());
  }
  if (from._internal_downs() != 0) {
    _this->_internal_set_downs(from._internal_downs());
  }
  if (from._internal_equals() != 0) {
    _this->_internal_set_equals(from._internal_equals());
  }
  if (from._internal_preups() != 0) {
    _this->_internal_set_preups(from._internal_preups());
  }
  if (from._internal_predowns() != 0) {
    _this->_internal_set_predowns(from._internal_predowns());
  }
  if (from._internal_preequals() != 0) {
    _this->_internal_set_preequals(from._internal_preequals());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_upspercent = from._internal_upspercent();
  uint64_t raw_upspercent;
  memcpy(&raw_upspercent, &tmp_upspercent, sizeof(tmp_upspercent));
  if (raw_upspercent != 0) {
    _this->_internal_set_upspercent(from._internal_upspercent());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_preupspercent = from._internal_preupspercent();
  uint64_t raw_preupspercent;
  memcpy(&raw_preupspercent, &tmp_preupspercent, sizeof(tmp_preupspercent));
  if (raw_preupspercent != 0) {
    _this->_internal_set_preupspercent(from._internal_preupspercent());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ADUpsDownsCount::CopyFrom(const ADUpsDownsCount& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.htsc.mdc.insight.model.ADUpsDownsCount)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ADUpsDownsCount::IsInitialized() const {
  return true;
}

void ADUpsDownsCount::InternalSwap(ADUpsDownsCount* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ADUpsDownsCount, _impl_.preupspercent_)
      + sizeof(ADUpsDownsCount::_impl_.preupspercent_)
      - PROTOBUF_FIELD_OFFSET(ADUpsDownsCount, _impl_.ups_)>(
          reinterpret_cast<char*>(&_impl_.ups_),
          reinterpret_cast<char*>(&other->_impl_.ups_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ADUpsDownsCount::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ADUpsDownsAnalysis_2eproto_getter, &descriptor_table_ADUpsDownsAnalysis_2eproto_once,
      file_level_metadata_ADUpsDownsAnalysis_2eproto[1]);
}

// ===================================================================

class ADUpsDownsLimitCount::_Internal {
 public:
};

ADUpsDownsLimitCount::ADUpsDownsLimitCount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:com.htsc.mdc.insight.model.ADUpsDownsLimitCount)
}
ADUpsDownsLimitCount::ADUpsDownsLimitCount(const ADUpsDownsLimitCount& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ADUpsDownsLimitCount* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.noreachedlimitpx_){}
    , decltype(_impl_.uplimits_){}
    , decltype(_impl_.downlimits_){}
    , decltype(_impl_.prenoreachedlimitpx_){}
    , decltype(_impl_.preuplimits_){}
    , decltype(_impl_.predownlimits_){}
    , decltype(_impl_.preuplimitsaveragechangepercent_){}
    , decltype(_impl_.uplimitspercent_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.noreachedlimitpx_, &from._impl_.noreachedlimitpx_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.uplimitspercent_) -
    reinterpret_cast<char*>(&_impl_.noreachedlimitpx_)) + sizeof(_impl_.uplimitspercent_));
  // @@protoc_insertion_point(copy_constructor:com.htsc.mdc.insight.model.ADUpsDownsLimitCount)
}

inline void ADUpsDownsLimitCount::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.noreachedlimitpx_){0}
    , decltype(_impl_.uplimits_){0}
    , decltype(_impl_.downlimits_){0}
    , decltype(_impl_.prenoreachedlimitpx_){0}
    , decltype(_impl_.preuplimits_){0}
    , decltype(_impl_.predownlimits_){0}
    , decltype(_impl_.preuplimitsaveragechangepercent_){0}
    , decltype(_impl_.uplimitspercent_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ADUpsDownsLimitCount::~ADUpsDownsLimitCount() {
  // @@protoc_insertion_point(destructor:com.htsc.mdc.insight.model.ADUpsDownsLimitCount)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ADUpsDownsLimitCount::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ADUpsDownsLimitCount::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ADUpsDownsLimitCount::Clear() {
// @@protoc_insertion_point(message_clear_start:com.htsc.mdc.insight.model.ADUpsDownsLimitCount)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.noreachedlimitpx_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.uplimitspercent_) -
      reinterpret_cast<char*>(&_impl_.noreachedlimitpx_)) + sizeof(_impl_.uplimitspercent_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ADUpsDownsLimitCount::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 NoReachedLimitPx = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.noreachedlimitpx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 UpLimits = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.uplimits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 DownLimits = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.downlimits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 PreNoReachedLimitPx = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.prenoreachedlimitpx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 PreUpLimits = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.preuplimits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 PreDownLimits = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.predownlimits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double PreUpLimitsAverageChangePercent = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _impl_.preuplimitsaveragechangepercent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double UpLimitsPercent = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _impl_.uplimitspercent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ADUpsDownsLimitCount::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.htsc.mdc.insight.model.ADUpsDownsLimitCount)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 NoReachedLimitPx = 1;
  if (this->_internal_noreachedlimitpx() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_noreachedlimitpx(), target);
  }

  // int32 UpLimits = 2;
  if (this->_internal_uplimits() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_uplimits(), target);
  }

  // int32 DownLimits = 3;
  if (this->_internal_downlimits() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_downlimits(), target);
  }

  // int32 PreNoReachedLimitPx = 4;
  if (this->_internal_prenoreachedlimitpx() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_prenoreachedlimitpx(), target);
  }

  // int32 PreUpLimits = 5;
  if (this->_internal_preuplimits() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_preuplimits(), target);
  }

  // int32 PreDownLimits = 6;
  if (this->_internal_predownlimits() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_predownlimits(), target);
  }

  // double PreUpLimitsAverageChangePercent = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_preuplimitsaveragechangepercent = this->_internal_preuplimitsaveragechangepercent();
  uint64_t raw_preuplimitsaveragechangepercent;
  memcpy(&raw_preuplimitsaveragechangepercent, &tmp_preuplimitsaveragechangepercent, sizeof(tmp_preuplimitsaveragechangepercent));
  if (raw_preuplimitsaveragechangepercent != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(7, this->_internal_preuplimitsaveragechangepercent(), target);
  }

  // double UpLimitsPercent = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_uplimitspercent = this->_internal_uplimitspercent();
  uint64_t raw_uplimitspercent;
  memcpy(&raw_uplimitspercent, &tmp_uplimitspercent, sizeof(tmp_uplimitspercent));
  if (raw_uplimitspercent != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(8, this->_internal_uplimitspercent(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:com.htsc.mdc.insight.model.ADUpsDownsLimitCount)
  return target;
}

size_t ADUpsDownsLimitCount::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.htsc.mdc.insight.model.ADUpsDownsLimitCount)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 NoReachedLimitPx = 1;
  if (this->_internal_noreachedlimitpx() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_noreachedlimitpx());
  }

  // int32 UpLimits = 2;
  if (this->_internal_uplimits() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_uplimits());
  }

  // int32 DownLimits = 3;
  if (this->_internal_downlimits() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_downlimits());
  }

  // int32 PreNoReachedLimitPx = 4;
  if (this->_internal_prenoreachedlimitpx() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_prenoreachedlimitpx());
  }

  // int32 PreUpLimits = 5;
  if (this->_internal_preuplimits() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_preuplimits());
  }

  // int32 PreDownLimits = 6;
  if (this->_internal_predownlimits() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_predownlimits());
  }

  // double PreUpLimitsAverageChangePercent = 7;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_preuplimitsaveragechangepercent = this->_internal_preuplimitsaveragechangepercent();
  uint64_t raw_preuplimitsaveragechangepercent;
  memcpy(&raw_preuplimitsaveragechangepercent, &tmp_preuplimitsaveragechangepercent, sizeof(tmp_preuplimitsaveragechangepercent));
  if (raw_preuplimitsaveragechangepercent != 0) {
    total_size += 1 + 8;
  }

  // double UpLimitsPercent = 8;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_uplimitspercent = this->_internal_uplimitspercent();
  uint64_t raw_uplimitspercent;
  memcpy(&raw_uplimitspercent, &tmp_uplimitspercent, sizeof(tmp_uplimitspercent));
  if (raw_uplimitspercent != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ADUpsDownsLimitCount::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ADUpsDownsLimitCount::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ADUpsDownsLimitCount::GetClassData() const { return &_class_data_; }


void ADUpsDownsLimitCount::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ADUpsDownsLimitCount*>(&to_msg);
  auto& from = static_cast<const ADUpsDownsLimitCount&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:com.htsc.mdc.insight.model.ADUpsDownsLimitCount)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_noreachedlimitpx() != 0) {
    _this->_internal_set_noreachedlimitpx(from._internal_noreachedlimitpx());
  }
  if (from._internal_uplimits() != 0) {
    _this->_internal_set_uplimits(from._internal_uplimits());
  }
  if (from._internal_downlimits() != 0) {
    _this->_internal_set_downlimits(from._internal_downlimits());
  }
  if (from._internal_prenoreachedlimitpx() != 0) {
    _this->_internal_set_prenoreachedlimitpx(from._internal_prenoreachedlimitpx());
  }
  if (from._internal_preuplimits() != 0) {
    _this->_internal_set_preuplimits(from._internal_preuplimits());
  }
  if (from._internal_predownlimits() != 0) {
    _this->_internal_set_predownlimits(from._internal_predownlimits());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_preuplimitsaveragechangepercent = from._internal_preuplimitsaveragechangepercent();
  uint64_t raw_preuplimitsaveragechangepercent;
  memcpy(&raw_preuplimitsaveragechangepercent, &tmp_preuplimitsaveragechangepercent, sizeof(tmp_preuplimitsaveragechangepercent));
  if (raw_preuplimitsaveragechangepercent != 0) {
    _this->_internal_set_preuplimitsaveragechangepercent(from._internal_preuplimitsaveragechangepercent());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_uplimitspercent = from._internal_uplimitspercent();
  uint64_t raw_uplimitspercent;
  memcpy(&raw_uplimitspercent, &tmp_uplimitspercent, sizeof(tmp_uplimitspercent));
  if (raw_uplimitspercent != 0) {
    _this->_internal_set_uplimitspercent(from._internal_uplimitspercent());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ADUpsDownsLimitCount::CopyFrom(const ADUpsDownsLimitCount& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.htsc.mdc.insight.model.ADUpsDownsLimitCount)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ADUpsDownsLimitCount::IsInitialized() const {
  return true;
}

void ADUpsDownsLimitCount::InternalSwap(ADUpsDownsLimitCount* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ADUpsDownsLimitCount, _impl_.uplimitspercent_)
      + sizeof(ADUpsDownsLimitCount::_impl_.uplimitspercent_)
      - PROTOBUF_FIELD_OFFSET(ADUpsDownsLimitCount, _impl_.noreachedlimitpx_)>(
          reinterpret_cast<char*>(&_impl_.noreachedlimitpx_),
          reinterpret_cast<char*>(&other->_impl_.noreachedlimitpx_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ADUpsDownsLimitCount::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ADUpsDownsAnalysis_2eproto_getter, &descriptor_table_ADUpsDownsAnalysis_2eproto_once,
      file_level_metadata_ADUpsDownsAnalysis_2eproto[2]);
}

// ===================================================================

class ADUpsDownsPartitionDetail::_Internal {
 public:
};

ADUpsDownsPartitionDetail::ADUpsDownsPartitionDetail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:com.htsc.mdc.insight.model.ADUpsDownsPartitionDetail)
}
ADUpsDownsPartitionDetail::ADUpsDownsPartitionDetail(const ADUpsDownsPartitionDetail& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ADUpsDownsPartitionDetail* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.numbers_){}
    , decltype(_impl_.partitionchangepercent_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.numbers_, &from._impl_.numbers_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.partitionchangepercent_) -
    reinterpret_cast<char*>(&_impl_.numbers_)) + sizeof(_impl_.partitionchangepercent_));
  // @@protoc_insertion_point(copy_constructor:com.htsc.mdc.insight.model.ADUpsDownsPartitionDetail)
}

inline void ADUpsDownsPartitionDetail::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.numbers_){0}
    , decltype(_impl_.partitionchangepercent_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ADUpsDownsPartitionDetail::~ADUpsDownsPartitionDetail() {
  // @@protoc_insertion_point(destructor:com.htsc.mdc.insight.model.ADUpsDownsPartitionDetail)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ADUpsDownsPartitionDetail::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ADUpsDownsPartitionDetail::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ADUpsDownsPartitionDetail::Clear() {
// @@protoc_insertion_point(message_clear_start:com.htsc.mdc.insight.model.ADUpsDownsPartitionDetail)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.numbers_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.partitionchangepercent_) -
      reinterpret_cast<char*>(&_impl_.numbers_)) + sizeof(_impl_.partitionchangepercent_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ADUpsDownsPartitionDetail::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 Numbers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.numbers_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 PartitionChangePercent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.partitionchangepercent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ADUpsDownsPartitionDetail::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:com.htsc.mdc.insight.model.ADUpsDownsPartitionDetail)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 Numbers = 1;
  if (this->_internal_numbers() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_numbers(), target);
  }

  // int32 PartitionChangePercent = 2;
  if (this->_internal_partitionchangepercent() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_partitionchangepercent(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:com.htsc.mdc.insight.model.ADUpsDownsPartitionDetail)
  return target;
}

size_t ADUpsDownsPartitionDetail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:com.htsc.mdc.insight.model.ADUpsDownsPartitionDetail)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 Numbers = 1;
  if (this->_internal_numbers() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_numbers());
  }

  // int32 PartitionChangePercent = 2;
  if (this->_internal_partitionchangepercent() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_partitionchangepercent());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ADUpsDownsPartitionDetail::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ADUpsDownsPartitionDetail::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ADUpsDownsPartitionDetail::GetClassData() const { return &_class_data_; }


void ADUpsDownsPartitionDetail::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ADUpsDownsPartitionDetail*>(&to_msg);
  auto& from = static_cast<const ADUpsDownsPartitionDetail&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:com.htsc.mdc.insight.model.ADUpsDownsPartitionDetail)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_numbers() != 0) {
    _this->_internal_set_numbers(from._internal_numbers());
  }
  if (from._internal_partitionchangepercent() != 0) {
    _this->_internal_set_partitionchangepercent(from._internal_partitionchangepercent());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ADUpsDownsPartitionDetail::CopyFrom(const ADUpsDownsPartitionDetail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:com.htsc.mdc.insight.model.ADUpsDownsPartitionDetail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ADUpsDownsPartitionDetail::IsInitialized() const {
  return true;
}

void ADUpsDownsPartitionDetail::InternalSwap(ADUpsDownsPartitionDetail* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ADUpsDownsPartitionDetail, _impl_.partitionchangepercent_)
      + sizeof(ADUpsDownsPartitionDetail::_impl_.partitionchangepercent_)
      - PROTOBUF_FIELD_OFFSET(ADUpsDownsPartitionDetail, _impl_.numbers_)>(
          reinterpret_cast<char*>(&_impl_.numbers_),
          reinterpret_cast<char*>(&other->_impl_.numbers_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ADUpsDownsPartitionDetail::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ADUpsDownsAnalysis_2eproto_getter, &descriptor_table_ADUpsDownsAnalysis_2eproto_once,
      file_level_metadata_ADUpsDownsAnalysis_2eproto[3]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace model
}  // namespace insight
}  // namespace mdc
}  // namespace htsc
}  // namespace com
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::com::htsc::mdc::insight::model::ADUpsDownsAnalysis*
Arena::CreateMaybeMessage< ::com::htsc::mdc::insight::model::ADUpsDownsAnalysis >(Arena* arena) {
  return Arena::CreateMessageInternal< ::com::htsc::mdc::insight::model::ADUpsDownsAnalysis >(arena);
}
template<> PROTOBUF_NOINLINE ::com::htsc::mdc::insight::model::ADUpsDownsCount*
Arena::CreateMaybeMessage< ::com::htsc::mdc::insight::model::ADUpsDownsCount >(Arena* arena) {
  return Arena::CreateMessageInternal< ::com::htsc::mdc::insight::model::ADUpsDownsCount >(arena);
}
template<> PROTOBUF_NOINLINE ::com::htsc::mdc::insight::model::ADUpsDownsLimitCount*
Arena::CreateMaybeMessage< ::com::htsc::mdc::insight::model::ADUpsDownsLimitCount >(Arena* arena) {
  return Arena::CreateMessageInternal< ::com::htsc::mdc::insight::model::ADUpsDownsLimitCount >(arena);
}
template<> PROTOBUF_NOINLINE ::com::htsc::mdc::insight::model::ADUpsDownsPartitionDetail*
Arena::CreateMaybeMessage< ::com::htsc::mdc::insight::model::ADUpsDownsPartitionDetail >(Arena* arena) {
  return Arena::CreateMessageInternal< ::com::htsc::mdc::insight::model::ADUpsDownsPartitionDetail >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
