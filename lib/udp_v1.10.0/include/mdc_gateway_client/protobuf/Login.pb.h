// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Login.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Login_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Login_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "ServiceDiscovery.pb.h"
#include "InsightErrorContext.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Login_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Login_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Login_2eproto;
namespace com {
namespace htsc {
namespace mdc {
namespace insight {
namespace model {
class AccountInfo;
struct AccountInfoDefaultTypeInternal;
extern AccountInfoDefaultTypeInternal _AccountInfo_default_instance_;
class DeviceInfo;
struct DeviceInfoDefaultTypeInternal;
extern DeviceInfoDefaultTypeInternal _DeviceInfo_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
struct LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class UserWithPassword;
struct UserWithPasswordDefaultTypeInternal;
extern UserWithPasswordDefaultTypeInternal _UserWithPassword_default_instance_;
class UserWithToken;
struct UserWithTokenDefaultTypeInternal;
extern UserWithTokenDefaultTypeInternal _UserWithToken_default_instance_;
}  // namespace model
}  // namespace insight
}  // namespace mdc
}  // namespace htsc
}  // namespace com
PROTOBUF_NAMESPACE_OPEN
template<> ::com::htsc::mdc::insight::model::AccountInfo* Arena::CreateMaybeMessage<::com::htsc::mdc::insight::model::AccountInfo>(Arena*);
template<> ::com::htsc::mdc::insight::model::DeviceInfo* Arena::CreateMaybeMessage<::com::htsc::mdc::insight::model::DeviceInfo>(Arena*);
template<> ::com::htsc::mdc::insight::model::LoginRequest* Arena::CreateMaybeMessage<::com::htsc::mdc::insight::model::LoginRequest>(Arena*);
template<> ::com::htsc::mdc::insight::model::LoginResponse* Arena::CreateMaybeMessage<::com::htsc::mdc::insight::model::LoginResponse>(Arena*);
template<> ::com::htsc::mdc::insight::model::UserWithPassword* Arena::CreateMaybeMessage<::com::htsc::mdc::insight::model::UserWithPassword>(Arena*);
template<> ::com::htsc::mdc::insight::model::UserWithToken* Arena::CreateMaybeMessage<::com::htsc::mdc::insight::model::UserWithToken>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace com {
namespace htsc {
namespace mdc {
namespace insight {
namespace model {

enum ELoginType : int {
  DEFAULT_LOGIN_TYPE = 0,
  INSIGHT_LOGIN_FOR_DISCOVERY = 1,
  THRID_PARTY_LOGIN_FOR_DISCOVERY = 2,
  LOGIN_FOR_SERVICE = 3,
  ELoginType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ELoginType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ELoginType_IsValid(int value);
constexpr ELoginType ELoginType_MIN = DEFAULT_LOGIN_TYPE;
constexpr ELoginType ELoginType_MAX = LOGIN_FOR_SERVICE;
constexpr int ELoginType_ARRAYSIZE = ELoginType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELoginType_descriptor();
template<typename T>
inline const std::string& ELoginType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ELoginType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ELoginType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ELoginType_descriptor(), enum_t_value);
}
inline bool ELoginType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ELoginType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ELoginType>(
    ELoginType_descriptor(), name, value);
}
// ===================================================================

class LoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.htsc.mdc.insight.model.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  explicit PROTOBUF_CONSTEXPR LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginRequest& from) {
    LoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.htsc.mdc.insight.model.LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppVersionFieldNumber = 2,
    kConnectServerIPFieldNumber = 8,
    kUwpFieldNumber = 4,
    kUwtFieldNumber = 5,
    kDeviceInfoFieldNumber = 6,
    kAppTypeFieldNumber = 1,
    kLoginTypeFieldNumber = 3,
    kIsSupportCompressedFieldNumber = 7,
  };
  // string appVersion = 2;
  void clear_appversion();
  const std::string& appversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_appversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_appversion();
  PROTOBUF_NODISCARD std::string* release_appversion();
  void set_allocated_appversion(std::string* appversion);
  private:
  const std::string& _internal_appversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_appversion(const std::string& value);
  std::string* _internal_mutable_appversion();
  public:

  // string connectServerIP = 8;
  void clear_connectserverip();
  const std::string& connectserverip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connectserverip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connectserverip();
  PROTOBUF_NODISCARD std::string* release_connectserverip();
  void set_allocated_connectserverip(std::string* connectserverip);
  private:
  const std::string& _internal_connectserverip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connectserverip(const std::string& value);
  std::string* _internal_mutable_connectserverip();
  public:

  // .com.htsc.mdc.insight.model.UserWithPassword uwp = 4;
  bool has_uwp() const;
  private:
  bool _internal_has_uwp() const;
  public:
  void clear_uwp();
  const ::com::htsc::mdc::insight::model::UserWithPassword& uwp() const;
  PROTOBUF_NODISCARD ::com::htsc::mdc::insight::model::UserWithPassword* release_uwp();
  ::com::htsc::mdc::insight::model::UserWithPassword* mutable_uwp();
  void set_allocated_uwp(::com::htsc::mdc::insight::model::UserWithPassword* uwp);
  private:
  const ::com::htsc::mdc::insight::model::UserWithPassword& _internal_uwp() const;
  ::com::htsc::mdc::insight::model::UserWithPassword* _internal_mutable_uwp();
  public:
  void unsafe_arena_set_allocated_uwp(
      ::com::htsc::mdc::insight::model::UserWithPassword* uwp);
  ::com::htsc::mdc::insight::model::UserWithPassword* unsafe_arena_release_uwp();

  // .com.htsc.mdc.insight.model.UserWithToken uwt = 5;
  bool has_uwt() const;
  private:
  bool _internal_has_uwt() const;
  public:
  void clear_uwt();
  const ::com::htsc::mdc::insight::model::UserWithToken& uwt() const;
  PROTOBUF_NODISCARD ::com::htsc::mdc::insight::model::UserWithToken* release_uwt();
  ::com::htsc::mdc::insight::model::UserWithToken* mutable_uwt();
  void set_allocated_uwt(::com::htsc::mdc::insight::model::UserWithToken* uwt);
  private:
  const ::com::htsc::mdc::insight::model::UserWithToken& _internal_uwt() const;
  ::com::htsc::mdc::insight::model::UserWithToken* _internal_mutable_uwt();
  public:
  void unsafe_arena_set_allocated_uwt(
      ::com::htsc::mdc::insight::model::UserWithToken* uwt);
  ::com::htsc::mdc::insight::model::UserWithToken* unsafe_arena_release_uwt();

  // .com.htsc.mdc.insight.model.DeviceInfo deviceInfo = 6;
  bool has_deviceinfo() const;
  private:
  bool _internal_has_deviceinfo() const;
  public:
  void clear_deviceinfo();
  const ::com::htsc::mdc::insight::model::DeviceInfo& deviceinfo() const;
  PROTOBUF_NODISCARD ::com::htsc::mdc::insight::model::DeviceInfo* release_deviceinfo();
  ::com::htsc::mdc::insight::model::DeviceInfo* mutable_deviceinfo();
  void set_allocated_deviceinfo(::com::htsc::mdc::insight::model::DeviceInfo* deviceinfo);
  private:
  const ::com::htsc::mdc::insight::model::DeviceInfo& _internal_deviceinfo() const;
  ::com::htsc::mdc::insight::model::DeviceInfo* _internal_mutable_deviceinfo();
  public:
  void unsafe_arena_set_allocated_deviceinfo(
      ::com::htsc::mdc::insight::model::DeviceInfo* deviceinfo);
  ::com::htsc::mdc::insight::model::DeviceInfo* unsafe_arena_release_deviceinfo();

  // int32 appType = 1;
  void clear_apptype();
  int32_t apptype() const;
  void set_apptype(int32_t value);
  private:
  int32_t _internal_apptype() const;
  void _internal_set_apptype(int32_t value);
  public:

  // .com.htsc.mdc.insight.model.ELoginType loginType = 3;
  void clear_logintype();
  ::com::htsc::mdc::insight::model::ELoginType logintype() const;
  void set_logintype(::com::htsc::mdc::insight::model::ELoginType value);
  private:
  ::com::htsc::mdc::insight::model::ELoginType _internal_logintype() const;
  void _internal_set_logintype(::com::htsc::mdc::insight::model::ELoginType value);
  public:

  // bool isSupportCompressed = 7;
  void clear_issupportcompressed();
  bool issupportcompressed() const;
  void set_issupportcompressed(bool value);
  private:
  bool _internal_issupportcompressed() const;
  void _internal_set_issupportcompressed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:com.htsc.mdc.insight.model.LoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appversion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connectserverip_;
    ::com::htsc::mdc::insight::model::UserWithPassword* uwp_;
    ::com::htsc::mdc::insight::model::UserWithToken* uwt_;
    ::com::htsc::mdc::insight::model::DeviceInfo* deviceinfo_;
    int32_t apptype_;
    int logintype_;
    bool issupportcompressed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Login_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.htsc.mdc.insight.model.LoginResponse) */ {
 public:
  inline LoginResponse() : LoginResponse(nullptr) {}
  ~LoginResponse() override;
  explicit PROTOBUF_CONSTEXPR LoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginResponse(const LoginResponse& from);
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginResponse& from) {
    LoginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.htsc.mdc.insight.model.LoginResponse";
  }
  protected:
  explicit LoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 3,
    kLastLoginIpFieldNumber = 5,
    kReservedInfoFieldNumber = 6,
    kDataSourceFieldNumber = 7,
    kSiteFieldNumber = 8,
    kErrorContextFieldNumber = 2,
    kServiceDiscoveryResponseFieldNumber = 9,
    kAccountInfoFieldNumber = 10,
    kLastLoginTimeFieldNumber = 4,
    kIsSuccessFieldNumber = 1,
  };
  // string token = 3;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // string lastLoginIp = 5;
  void clear_lastloginip();
  const std::string& lastloginip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lastloginip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lastloginip();
  PROTOBUF_NODISCARD std::string* release_lastloginip();
  void set_allocated_lastloginip(std::string* lastloginip);
  private:
  const std::string& _internal_lastloginip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lastloginip(const std::string& value);
  std::string* _internal_mutable_lastloginip();
  public:

  // string reservedInfo = 6;
  void clear_reservedinfo();
  const std::string& reservedinfo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reservedinfo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reservedinfo();
  PROTOBUF_NODISCARD std::string* release_reservedinfo();
  void set_allocated_reservedinfo(std::string* reservedinfo);
  private:
  const std::string& _internal_reservedinfo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reservedinfo(const std::string& value);
  std::string* _internal_mutable_reservedinfo();
  public:

  // string dataSource = 7;
  void clear_datasource();
  const std::string& datasource() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_datasource(ArgT0&& arg0, ArgT... args);
  std::string* mutable_datasource();
  PROTOBUF_NODISCARD std::string* release_datasource();
  void set_allocated_datasource(std::string* datasource);
  private:
  const std::string& _internal_datasource() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_datasource(const std::string& value);
  std::string* _internal_mutable_datasource();
  public:

  // string site = 8;
  void clear_site();
  const std::string& site() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_site(ArgT0&& arg0, ArgT... args);
  std::string* mutable_site();
  PROTOBUF_NODISCARD std::string* release_site();
  void set_allocated_site(std::string* site);
  private:
  const std::string& _internal_site() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_site(const std::string& value);
  std::string* _internal_mutable_site();
  public:

  // .com.htsc.mdc.insight.model.InsightErrorContext errorContext = 2;
  bool has_errorcontext() const;
  private:
  bool _internal_has_errorcontext() const;
  public:
  void clear_errorcontext();
  const ::com::htsc::mdc::insight::model::InsightErrorContext& errorcontext() const;
  PROTOBUF_NODISCARD ::com::htsc::mdc::insight::model::InsightErrorContext* release_errorcontext();
  ::com::htsc::mdc::insight::model::InsightErrorContext* mutable_errorcontext();
  void set_allocated_errorcontext(::com::htsc::mdc::insight::model::InsightErrorContext* errorcontext);
  private:
  const ::com::htsc::mdc::insight::model::InsightErrorContext& _internal_errorcontext() const;
  ::com::htsc::mdc::insight::model::InsightErrorContext* _internal_mutable_errorcontext();
  public:
  void unsafe_arena_set_allocated_errorcontext(
      ::com::htsc::mdc::insight::model::InsightErrorContext* errorcontext);
  ::com::htsc::mdc::insight::model::InsightErrorContext* unsafe_arena_release_errorcontext();

  // .com.htsc.mdc.insight.model.ServiceDiscoveryResponse serviceDiscoveryResponse = 9;
  bool has_servicediscoveryresponse() const;
  private:
  bool _internal_has_servicediscoveryresponse() const;
  public:
  void clear_servicediscoveryresponse();
  const ::com::htsc::mdc::insight::model::ServiceDiscoveryResponse& servicediscoveryresponse() const;
  PROTOBUF_NODISCARD ::com::htsc::mdc::insight::model::ServiceDiscoveryResponse* release_servicediscoveryresponse();
  ::com::htsc::mdc::insight::model::ServiceDiscoveryResponse* mutable_servicediscoveryresponse();
  void set_allocated_servicediscoveryresponse(::com::htsc::mdc::insight::model::ServiceDiscoveryResponse* servicediscoveryresponse);
  private:
  const ::com::htsc::mdc::insight::model::ServiceDiscoveryResponse& _internal_servicediscoveryresponse() const;
  ::com::htsc::mdc::insight::model::ServiceDiscoveryResponse* _internal_mutable_servicediscoveryresponse();
  public:
  void unsafe_arena_set_allocated_servicediscoveryresponse(
      ::com::htsc::mdc::insight::model::ServiceDiscoveryResponse* servicediscoveryresponse);
  ::com::htsc::mdc::insight::model::ServiceDiscoveryResponse* unsafe_arena_release_servicediscoveryresponse();

  // .com.htsc.mdc.insight.model.AccountInfo accountInfo = 10;
  bool has_accountinfo() const;
  private:
  bool _internal_has_accountinfo() const;
  public:
  void clear_accountinfo();
  const ::com::htsc::mdc::insight::model::AccountInfo& accountinfo() const;
  PROTOBUF_NODISCARD ::com::htsc::mdc::insight::model::AccountInfo* release_accountinfo();
  ::com::htsc::mdc::insight::model::AccountInfo* mutable_accountinfo();
  void set_allocated_accountinfo(::com::htsc::mdc::insight::model::AccountInfo* accountinfo);
  private:
  const ::com::htsc::mdc::insight::model::AccountInfo& _internal_accountinfo() const;
  ::com::htsc::mdc::insight::model::AccountInfo* _internal_mutable_accountinfo();
  public:
  void unsafe_arena_set_allocated_accountinfo(
      ::com::htsc::mdc::insight::model::AccountInfo* accountinfo);
  ::com::htsc::mdc::insight::model::AccountInfo* unsafe_arena_release_accountinfo();

  // int64 lastLoginTime = 4;
  void clear_lastlogintime();
  int64_t lastlogintime() const;
  void set_lastlogintime(int64_t value);
  private:
  int64_t _internal_lastlogintime() const;
  void _internal_set_lastlogintime(int64_t value);
  public:

  // bool isSuccess = 1;
  void clear_issuccess();
  bool issuccess() const;
  void set_issuccess(bool value);
  private:
  bool _internal_issuccess() const;
  void _internal_set_issuccess(bool value);
  public:

  // @@protoc_insertion_point(class_scope:com.htsc.mdc.insight.model.LoginResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lastloginip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reservedinfo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr datasource_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr site_;
    ::com::htsc::mdc::insight::model::InsightErrorContext* errorcontext_;
    ::com::htsc::mdc::insight::model::ServiceDiscoveryResponse* servicediscoveryresponse_;
    ::com::htsc::mdc::insight::model::AccountInfo* accountinfo_;
    int64_t lastlogintime_;
    bool issuccess_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Login_2eproto;
};
// -------------------------------------------------------------------

class UserWithPassword final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.htsc.mdc.insight.model.UserWithPassword) */ {
 public:
  inline UserWithPassword() : UserWithPassword(nullptr) {}
  ~UserWithPassword() override;
  explicit PROTOBUF_CONSTEXPR UserWithPassword(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserWithPassword(const UserWithPassword& from);
  UserWithPassword(UserWithPassword&& from) noexcept
    : UserWithPassword() {
    *this = ::std::move(from);
  }

  inline UserWithPassword& operator=(const UserWithPassword& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserWithPassword& operator=(UserWithPassword&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserWithPassword& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserWithPassword* internal_default_instance() {
    return reinterpret_cast<const UserWithPassword*>(
               &_UserWithPassword_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UserWithPassword& a, UserWithPassword& b) {
    a.Swap(&b);
  }
  inline void Swap(UserWithPassword* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserWithPassword* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserWithPassword* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserWithPassword>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserWithPassword& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserWithPassword& from) {
    UserWithPassword::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserWithPassword* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.htsc.mdc.insight.model.UserWithPassword";
  }
  protected:
  explicit UserWithPassword(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kOtpFieldNumber = 3,
    kCaptchaFieldNumber = 4,
    kSmsFieldNumber = 5,
  };
  // string userName = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string password = 2;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string otp = 3;
  void clear_otp();
  const std::string& otp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_otp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_otp();
  PROTOBUF_NODISCARD std::string* release_otp();
  void set_allocated_otp(std::string* otp);
  private:
  const std::string& _internal_otp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_otp(const std::string& value);
  std::string* _internal_mutable_otp();
  public:

  // string captcha = 4;
  void clear_captcha();
  const std::string& captcha() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_captcha(ArgT0&& arg0, ArgT... args);
  std::string* mutable_captcha();
  PROTOBUF_NODISCARD std::string* release_captcha();
  void set_allocated_captcha(std::string* captcha);
  private:
  const std::string& _internal_captcha() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_captcha(const std::string& value);
  std::string* _internal_mutable_captcha();
  public:

  // string sms = 5;
  void clear_sms();
  const std::string& sms() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sms(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sms();
  PROTOBUF_NODISCARD std::string* release_sms();
  void set_allocated_sms(std::string* sms);
  private:
  const std::string& _internal_sms() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sms(const std::string& value);
  std::string* _internal_mutable_sms();
  public:

  // @@protoc_insertion_point(class_scope:com.htsc.mdc.insight.model.UserWithPassword)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr otp_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr captcha_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Login_2eproto;
};
// -------------------------------------------------------------------

class UserWithToken final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.htsc.mdc.insight.model.UserWithToken) */ {
 public:
  inline UserWithToken() : UserWithToken(nullptr) {}
  ~UserWithToken() override;
  explicit PROTOBUF_CONSTEXPR UserWithToken(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserWithToken(const UserWithToken& from);
  UserWithToken(UserWithToken&& from) noexcept
    : UserWithToken() {
    *this = ::std::move(from);
  }

  inline UserWithToken& operator=(const UserWithToken& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserWithToken& operator=(UserWithToken&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserWithToken& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserWithToken* internal_default_instance() {
    return reinterpret_cast<const UserWithToken*>(
               &_UserWithToken_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UserWithToken& a, UserWithToken& b) {
    a.Swap(&b);
  }
  inline void Swap(UserWithToken* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserWithToken* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserWithToken* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserWithToken>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserWithToken& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserWithToken& from) {
    UserWithToken::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserWithToken* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.htsc.mdc.insight.model.UserWithToken";
  }
  protected:
  explicit UserWithToken(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 1,
    kTokenFieldNumber = 2,
  };
  // string userName = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string token = 2;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // @@protoc_insertion_point(class_scope:com.htsc.mdc.insight.model.UserWithToken)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Login_2eproto;
};
// -------------------------------------------------------------------

class DeviceInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.htsc.mdc.insight.model.DeviceInfo) */ {
 public:
  inline DeviceInfo() : DeviceInfo(nullptr) {}
  ~DeviceInfo() override;
  explicit PROTOBUF_CONSTEXPR DeviceInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceInfo(const DeviceInfo& from);
  DeviceInfo(DeviceInfo&& from) noexcept
    : DeviceInfo() {
    *this = ::std::move(from);
  }

  inline DeviceInfo& operator=(const DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceInfo& operator=(DeviceInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceInfo* internal_default_instance() {
    return reinterpret_cast<const DeviceInfo*>(
               &_DeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DeviceInfo& a, DeviceInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceInfo& from) {
    DeviceInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.htsc.mdc.insight.model.DeviceInfo";
  }
  protected:
  explicit DeviceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceIdFieldNumber = 1,
    kDeviceMacFieldNumber = 2,
    kDeviceHarddiskFieldNumber = 3,
    kDeviceCPUFieldNumber = 4,
    kCellphoneNumberFieldNumber = 5,
    kCellphoneImeiFieldNumber = 6,
  };
  // string deviceId = 1;
  void clear_deviceid();
  const std::string& deviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceid();
  PROTOBUF_NODISCARD std::string* release_deviceid();
  void set_allocated_deviceid(std::string* deviceid);
  private:
  const std::string& _internal_deviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceid(const std::string& value);
  std::string* _internal_mutable_deviceid();
  public:

  // string deviceMac = 2;
  void clear_devicemac();
  const std::string& devicemac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devicemac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devicemac();
  PROTOBUF_NODISCARD std::string* release_devicemac();
  void set_allocated_devicemac(std::string* devicemac);
  private:
  const std::string& _internal_devicemac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devicemac(const std::string& value);
  std::string* _internal_mutable_devicemac();
  public:

  // string deviceHarddisk = 3;
  void clear_deviceharddisk();
  const std::string& deviceharddisk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceharddisk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceharddisk();
  PROTOBUF_NODISCARD std::string* release_deviceharddisk();
  void set_allocated_deviceharddisk(std::string* deviceharddisk);
  private:
  const std::string& _internal_deviceharddisk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceharddisk(const std::string& value);
  std::string* _internal_mutable_deviceharddisk();
  public:

  // string deviceCPU = 4;
  void clear_devicecpu();
  const std::string& devicecpu() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_devicecpu(ArgT0&& arg0, ArgT... args);
  std::string* mutable_devicecpu();
  PROTOBUF_NODISCARD std::string* release_devicecpu();
  void set_allocated_devicecpu(std::string* devicecpu);
  private:
  const std::string& _internal_devicecpu() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_devicecpu(const std::string& value);
  std::string* _internal_mutable_devicecpu();
  public:

  // string cellphoneNumber = 5;
  void clear_cellphonenumber();
  const std::string& cellphonenumber() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cellphonenumber(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cellphonenumber();
  PROTOBUF_NODISCARD std::string* release_cellphonenumber();
  void set_allocated_cellphonenumber(std::string* cellphonenumber);
  private:
  const std::string& _internal_cellphonenumber() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cellphonenumber(const std::string& value);
  std::string* _internal_mutable_cellphonenumber();
  public:

  // string cellphoneImei = 6;
  void clear_cellphoneimei();
  const std::string& cellphoneimei() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cellphoneimei(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cellphoneimei();
  PROTOBUF_NODISCARD std::string* release_cellphoneimei();
  void set_allocated_cellphoneimei(std::string* cellphoneimei);
  private:
  const std::string& _internal_cellphoneimei() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cellphoneimei(const std::string& value);
  std::string* _internal_mutable_cellphoneimei();
  public:

  // @@protoc_insertion_point(class_scope:com.htsc.mdc.insight.model.DeviceInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devicemac_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceharddisk_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr devicecpu_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cellphonenumber_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cellphoneimei_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Login_2eproto;
};
// -------------------------------------------------------------------

class AccountInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.htsc.mdc.insight.model.AccountInfo) */ {
 public:
  inline AccountInfo() : AccountInfo(nullptr) {}
  ~AccountInfo() override;
  explicit PROTOBUF_CONSTEXPR AccountInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountInfo(const AccountInfo& from);
  AccountInfo(AccountInfo&& from) noexcept
    : AccountInfo() {
    *this = ::std::move(from);
  }

  inline AccountInfo& operator=(const AccountInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountInfo& operator=(AccountInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountInfo* internal_default_instance() {
    return reinterpret_cast<const AccountInfo*>(
               &_AccountInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AccountInfo& a, AccountInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AccountInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AccountInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AccountInfo& from) {
    AccountInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.htsc.mdc.insight.model.AccountInfo";
  }
  protected:
  explicit AccountInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 1,
    kStartDateFieldNumber = 2,
    kStopDateFieldNumber = 3,
    kCustomerNameFieldNumber = 4,
    kContactPersonFieldNumber = 5,
    kContactAddressFieldNumber = 6,
    kContactTelFieldNumber = 7,
    kContactEmailFieldNumber = 8,
  };
  // string userName = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string startDate = 2;
  void clear_startdate();
  const std::string& startdate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_startdate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_startdate();
  PROTOBUF_NODISCARD std::string* release_startdate();
  void set_allocated_startdate(std::string* startdate);
  private:
  const std::string& _internal_startdate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_startdate(const std::string& value);
  std::string* _internal_mutable_startdate();
  public:

  // string stopDate = 3;
  void clear_stopdate();
  const std::string& stopdate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stopdate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stopdate();
  PROTOBUF_NODISCARD std::string* release_stopdate();
  void set_allocated_stopdate(std::string* stopdate);
  private:
  const std::string& _internal_stopdate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stopdate(const std::string& value);
  std::string* _internal_mutable_stopdate();
  public:

  // string customerName = 4;
  void clear_customername();
  const std::string& customername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_customername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_customername();
  PROTOBUF_NODISCARD std::string* release_customername();
  void set_allocated_customername(std::string* customername);
  private:
  const std::string& _internal_customername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_customername(const std::string& value);
  std::string* _internal_mutable_customername();
  public:

  // string contactPerson = 5;
  void clear_contactperson();
  const std::string& contactperson() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contactperson(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contactperson();
  PROTOBUF_NODISCARD std::string* release_contactperson();
  void set_allocated_contactperson(std::string* contactperson);
  private:
  const std::string& _internal_contactperson() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contactperson(const std::string& value);
  std::string* _internal_mutable_contactperson();
  public:

  // string contactAddress = 6;
  void clear_contactaddress();
  const std::string& contactaddress() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contactaddress(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contactaddress();
  PROTOBUF_NODISCARD std::string* release_contactaddress();
  void set_allocated_contactaddress(std::string* contactaddress);
  private:
  const std::string& _internal_contactaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contactaddress(const std::string& value);
  std::string* _internal_mutable_contactaddress();
  public:

  // string contactTel = 7;
  void clear_contacttel();
  const std::string& contacttel() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contacttel(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contacttel();
  PROTOBUF_NODISCARD std::string* release_contacttel();
  void set_allocated_contacttel(std::string* contacttel);
  private:
  const std::string& _internal_contacttel() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contacttel(const std::string& value);
  std::string* _internal_mutable_contacttel();
  public:

  // string contactEmail = 8;
  void clear_contactemail();
  const std::string& contactemail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contactemail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contactemail();
  PROTOBUF_NODISCARD std::string* release_contactemail();
  void set_allocated_contactemail(std::string* contactemail);
  private:
  const std::string& _internal_contactemail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contactemail(const std::string& value);
  std::string* _internal_mutable_contactemail();
  public:

  // @@protoc_insertion_point(class_scope:com.htsc.mdc.insight.model.AccountInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr startdate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stopdate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr customername_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contactperson_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contactaddress_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contacttel_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contactemail_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Login_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LoginRequest

// int32 appType = 1;
inline void LoginRequest::clear_apptype() {
  _impl_.apptype_ = 0;
}
inline int32_t LoginRequest::_internal_apptype() const {
  return _impl_.apptype_;
}
inline int32_t LoginRequest::apptype() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.LoginRequest.appType)
  return _internal_apptype();
}
inline void LoginRequest::_internal_set_apptype(int32_t value) {
  
  _impl_.apptype_ = value;
}
inline void LoginRequest::set_apptype(int32_t value) {
  _internal_set_apptype(value);
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.LoginRequest.appType)
}

// string appVersion = 2;
inline void LoginRequest::clear_appversion() {
  _impl_.appversion_.ClearToEmpty();
}
inline const std::string& LoginRequest::appversion() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.LoginRequest.appVersion)
  return _internal_appversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_appversion(ArgT0&& arg0, ArgT... args) {
 
 _impl_.appversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.LoginRequest.appVersion)
}
inline std::string* LoginRequest::mutable_appversion() {
  std::string* _s = _internal_mutable_appversion();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.LoginRequest.appVersion)
  return _s;
}
inline const std::string& LoginRequest::_internal_appversion() const {
  return _impl_.appversion_.Get();
}
inline void LoginRequest::_internal_set_appversion(const std::string& value) {
  
  _impl_.appversion_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_appversion() {
  
  return _impl_.appversion_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_appversion() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.LoginRequest.appVersion)
  return _impl_.appversion_.Release();
}
inline void LoginRequest::set_allocated_appversion(std::string* appversion) {
  if (appversion != nullptr) {
    
  } else {
    
  }
  _impl_.appversion_.SetAllocated(appversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.appversion_.IsDefault()) {
    _impl_.appversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.LoginRequest.appVersion)
}

// .com.htsc.mdc.insight.model.ELoginType loginType = 3;
inline void LoginRequest::clear_logintype() {
  _impl_.logintype_ = 0;
}
inline ::com::htsc::mdc::insight::model::ELoginType LoginRequest::_internal_logintype() const {
  return static_cast< ::com::htsc::mdc::insight::model::ELoginType >(_impl_.logintype_);
}
inline ::com::htsc::mdc::insight::model::ELoginType LoginRequest::logintype() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.LoginRequest.loginType)
  return _internal_logintype();
}
inline void LoginRequest::_internal_set_logintype(::com::htsc::mdc::insight::model::ELoginType value) {
  
  _impl_.logintype_ = value;
}
inline void LoginRequest::set_logintype(::com::htsc::mdc::insight::model::ELoginType value) {
  _internal_set_logintype(value);
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.LoginRequest.loginType)
}

// .com.htsc.mdc.insight.model.UserWithPassword uwp = 4;
inline bool LoginRequest::_internal_has_uwp() const {
  return this != internal_default_instance() && _impl_.uwp_ != nullptr;
}
inline bool LoginRequest::has_uwp() const {
  return _internal_has_uwp();
}
inline void LoginRequest::clear_uwp() {
  if (GetArenaForAllocation() == nullptr && _impl_.uwp_ != nullptr) {
    delete _impl_.uwp_;
  }
  _impl_.uwp_ = nullptr;
}
inline const ::com::htsc::mdc::insight::model::UserWithPassword& LoginRequest::_internal_uwp() const {
  const ::com::htsc::mdc::insight::model::UserWithPassword* p = _impl_.uwp_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::htsc::mdc::insight::model::UserWithPassword&>(
      ::com::htsc::mdc::insight::model::_UserWithPassword_default_instance_);
}
inline const ::com::htsc::mdc::insight::model::UserWithPassword& LoginRequest::uwp() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.LoginRequest.uwp)
  return _internal_uwp();
}
inline void LoginRequest::unsafe_arena_set_allocated_uwp(
    ::com::htsc::mdc::insight::model::UserWithPassword* uwp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uwp_);
  }
  _impl_.uwp_ = uwp;
  if (uwp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.htsc.mdc.insight.model.LoginRequest.uwp)
}
inline ::com::htsc::mdc::insight::model::UserWithPassword* LoginRequest::release_uwp() {
  
  ::com::htsc::mdc::insight::model::UserWithPassword* temp = _impl_.uwp_;
  _impl_.uwp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::com::htsc::mdc::insight::model::UserWithPassword* LoginRequest::unsafe_arena_release_uwp() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.LoginRequest.uwp)
  
  ::com::htsc::mdc::insight::model::UserWithPassword* temp = _impl_.uwp_;
  _impl_.uwp_ = nullptr;
  return temp;
}
inline ::com::htsc::mdc::insight::model::UserWithPassword* LoginRequest::_internal_mutable_uwp() {
  
  if (_impl_.uwp_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::htsc::mdc::insight::model::UserWithPassword>(GetArenaForAllocation());
    _impl_.uwp_ = p;
  }
  return _impl_.uwp_;
}
inline ::com::htsc::mdc::insight::model::UserWithPassword* LoginRequest::mutable_uwp() {
  ::com::htsc::mdc::insight::model::UserWithPassword* _msg = _internal_mutable_uwp();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.LoginRequest.uwp)
  return _msg;
}
inline void LoginRequest::set_allocated_uwp(::com::htsc::mdc::insight::model::UserWithPassword* uwp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.uwp_;
  }
  if (uwp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(uwp);
    if (message_arena != submessage_arena) {
      uwp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uwp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.uwp_ = uwp;
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.LoginRequest.uwp)
}

// .com.htsc.mdc.insight.model.UserWithToken uwt = 5;
inline bool LoginRequest::_internal_has_uwt() const {
  return this != internal_default_instance() && _impl_.uwt_ != nullptr;
}
inline bool LoginRequest::has_uwt() const {
  return _internal_has_uwt();
}
inline void LoginRequest::clear_uwt() {
  if (GetArenaForAllocation() == nullptr && _impl_.uwt_ != nullptr) {
    delete _impl_.uwt_;
  }
  _impl_.uwt_ = nullptr;
}
inline const ::com::htsc::mdc::insight::model::UserWithToken& LoginRequest::_internal_uwt() const {
  const ::com::htsc::mdc::insight::model::UserWithToken* p = _impl_.uwt_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::htsc::mdc::insight::model::UserWithToken&>(
      ::com::htsc::mdc::insight::model::_UserWithToken_default_instance_);
}
inline const ::com::htsc::mdc::insight::model::UserWithToken& LoginRequest::uwt() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.LoginRequest.uwt)
  return _internal_uwt();
}
inline void LoginRequest::unsafe_arena_set_allocated_uwt(
    ::com::htsc::mdc::insight::model::UserWithToken* uwt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.uwt_);
  }
  _impl_.uwt_ = uwt;
  if (uwt) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.htsc.mdc.insight.model.LoginRequest.uwt)
}
inline ::com::htsc::mdc::insight::model::UserWithToken* LoginRequest::release_uwt() {
  
  ::com::htsc::mdc::insight::model::UserWithToken* temp = _impl_.uwt_;
  _impl_.uwt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::com::htsc::mdc::insight::model::UserWithToken* LoginRequest::unsafe_arena_release_uwt() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.LoginRequest.uwt)
  
  ::com::htsc::mdc::insight::model::UserWithToken* temp = _impl_.uwt_;
  _impl_.uwt_ = nullptr;
  return temp;
}
inline ::com::htsc::mdc::insight::model::UserWithToken* LoginRequest::_internal_mutable_uwt() {
  
  if (_impl_.uwt_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::htsc::mdc::insight::model::UserWithToken>(GetArenaForAllocation());
    _impl_.uwt_ = p;
  }
  return _impl_.uwt_;
}
inline ::com::htsc::mdc::insight::model::UserWithToken* LoginRequest::mutable_uwt() {
  ::com::htsc::mdc::insight::model::UserWithToken* _msg = _internal_mutable_uwt();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.LoginRequest.uwt)
  return _msg;
}
inline void LoginRequest::set_allocated_uwt(::com::htsc::mdc::insight::model::UserWithToken* uwt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.uwt_;
  }
  if (uwt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(uwt);
    if (message_arena != submessage_arena) {
      uwt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, uwt, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.uwt_ = uwt;
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.LoginRequest.uwt)
}

// .com.htsc.mdc.insight.model.DeviceInfo deviceInfo = 6;
inline bool LoginRequest::_internal_has_deviceinfo() const {
  return this != internal_default_instance() && _impl_.deviceinfo_ != nullptr;
}
inline bool LoginRequest::has_deviceinfo() const {
  return _internal_has_deviceinfo();
}
inline void LoginRequest::clear_deviceinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.deviceinfo_ != nullptr) {
    delete _impl_.deviceinfo_;
  }
  _impl_.deviceinfo_ = nullptr;
}
inline const ::com::htsc::mdc::insight::model::DeviceInfo& LoginRequest::_internal_deviceinfo() const {
  const ::com::htsc::mdc::insight::model::DeviceInfo* p = _impl_.deviceinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::htsc::mdc::insight::model::DeviceInfo&>(
      ::com::htsc::mdc::insight::model::_DeviceInfo_default_instance_);
}
inline const ::com::htsc::mdc::insight::model::DeviceInfo& LoginRequest::deviceinfo() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.LoginRequest.deviceInfo)
  return _internal_deviceinfo();
}
inline void LoginRequest::unsafe_arena_set_allocated_deviceinfo(
    ::com::htsc::mdc::insight::model::DeviceInfo* deviceinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deviceinfo_);
  }
  _impl_.deviceinfo_ = deviceinfo;
  if (deviceinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.htsc.mdc.insight.model.LoginRequest.deviceInfo)
}
inline ::com::htsc::mdc::insight::model::DeviceInfo* LoginRequest::release_deviceinfo() {
  
  ::com::htsc::mdc::insight::model::DeviceInfo* temp = _impl_.deviceinfo_;
  _impl_.deviceinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::com::htsc::mdc::insight::model::DeviceInfo* LoginRequest::unsafe_arena_release_deviceinfo() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.LoginRequest.deviceInfo)
  
  ::com::htsc::mdc::insight::model::DeviceInfo* temp = _impl_.deviceinfo_;
  _impl_.deviceinfo_ = nullptr;
  return temp;
}
inline ::com::htsc::mdc::insight::model::DeviceInfo* LoginRequest::_internal_mutable_deviceinfo() {
  
  if (_impl_.deviceinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::htsc::mdc::insight::model::DeviceInfo>(GetArenaForAllocation());
    _impl_.deviceinfo_ = p;
  }
  return _impl_.deviceinfo_;
}
inline ::com::htsc::mdc::insight::model::DeviceInfo* LoginRequest::mutable_deviceinfo() {
  ::com::htsc::mdc::insight::model::DeviceInfo* _msg = _internal_mutable_deviceinfo();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.LoginRequest.deviceInfo)
  return _msg;
}
inline void LoginRequest::set_allocated_deviceinfo(::com::htsc::mdc::insight::model::DeviceInfo* deviceinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.deviceinfo_;
  }
  if (deviceinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(deviceinfo);
    if (message_arena != submessage_arena) {
      deviceinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deviceinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.deviceinfo_ = deviceinfo;
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.LoginRequest.deviceInfo)
}

// bool isSupportCompressed = 7;
inline void LoginRequest::clear_issupportcompressed() {
  _impl_.issupportcompressed_ = false;
}
inline bool LoginRequest::_internal_issupportcompressed() const {
  return _impl_.issupportcompressed_;
}
inline bool LoginRequest::issupportcompressed() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.LoginRequest.isSupportCompressed)
  return _internal_issupportcompressed();
}
inline void LoginRequest::_internal_set_issupportcompressed(bool value) {
  
  _impl_.issupportcompressed_ = value;
}
inline void LoginRequest::set_issupportcompressed(bool value) {
  _internal_set_issupportcompressed(value);
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.LoginRequest.isSupportCompressed)
}

// string connectServerIP = 8;
inline void LoginRequest::clear_connectserverip() {
  _impl_.connectserverip_.ClearToEmpty();
}
inline const std::string& LoginRequest::connectserverip() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.LoginRequest.connectServerIP)
  return _internal_connectserverip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_connectserverip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.connectserverip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.LoginRequest.connectServerIP)
}
inline std::string* LoginRequest::mutable_connectserverip() {
  std::string* _s = _internal_mutable_connectserverip();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.LoginRequest.connectServerIP)
  return _s;
}
inline const std::string& LoginRequest::_internal_connectserverip() const {
  return _impl_.connectserverip_.Get();
}
inline void LoginRequest::_internal_set_connectserverip(const std::string& value) {
  
  _impl_.connectserverip_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_connectserverip() {
  
  return _impl_.connectserverip_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_connectserverip() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.LoginRequest.connectServerIP)
  return _impl_.connectserverip_.Release();
}
inline void LoginRequest::set_allocated_connectserverip(std::string* connectserverip) {
  if (connectserverip != nullptr) {
    
  } else {
    
  }
  _impl_.connectserverip_.SetAllocated(connectserverip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.connectserverip_.IsDefault()) {
    _impl_.connectserverip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.LoginRequest.connectServerIP)
}

// -------------------------------------------------------------------

// LoginResponse

// bool isSuccess = 1;
inline void LoginResponse::clear_issuccess() {
  _impl_.issuccess_ = false;
}
inline bool LoginResponse::_internal_issuccess() const {
  return _impl_.issuccess_;
}
inline bool LoginResponse::issuccess() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.LoginResponse.isSuccess)
  return _internal_issuccess();
}
inline void LoginResponse::_internal_set_issuccess(bool value) {
  
  _impl_.issuccess_ = value;
}
inline void LoginResponse::set_issuccess(bool value) {
  _internal_set_issuccess(value);
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.LoginResponse.isSuccess)
}

// .com.htsc.mdc.insight.model.InsightErrorContext errorContext = 2;
inline bool LoginResponse::_internal_has_errorcontext() const {
  return this != internal_default_instance() && _impl_.errorcontext_ != nullptr;
}
inline bool LoginResponse::has_errorcontext() const {
  return _internal_has_errorcontext();
}
inline const ::com::htsc::mdc::insight::model::InsightErrorContext& LoginResponse::_internal_errorcontext() const {
  const ::com::htsc::mdc::insight::model::InsightErrorContext* p = _impl_.errorcontext_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::htsc::mdc::insight::model::InsightErrorContext&>(
      ::com::htsc::mdc::insight::model::_InsightErrorContext_default_instance_);
}
inline const ::com::htsc::mdc::insight::model::InsightErrorContext& LoginResponse::errorcontext() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.LoginResponse.errorContext)
  return _internal_errorcontext();
}
inline void LoginResponse::unsafe_arena_set_allocated_errorcontext(
    ::com::htsc::mdc::insight::model::InsightErrorContext* errorcontext) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.errorcontext_);
  }
  _impl_.errorcontext_ = errorcontext;
  if (errorcontext) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.htsc.mdc.insight.model.LoginResponse.errorContext)
}
inline ::com::htsc::mdc::insight::model::InsightErrorContext* LoginResponse::release_errorcontext() {
  
  ::com::htsc::mdc::insight::model::InsightErrorContext* temp = _impl_.errorcontext_;
  _impl_.errorcontext_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::com::htsc::mdc::insight::model::InsightErrorContext* LoginResponse::unsafe_arena_release_errorcontext() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.LoginResponse.errorContext)
  
  ::com::htsc::mdc::insight::model::InsightErrorContext* temp = _impl_.errorcontext_;
  _impl_.errorcontext_ = nullptr;
  return temp;
}
inline ::com::htsc::mdc::insight::model::InsightErrorContext* LoginResponse::_internal_mutable_errorcontext() {
  
  if (_impl_.errorcontext_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::htsc::mdc::insight::model::InsightErrorContext>(GetArenaForAllocation());
    _impl_.errorcontext_ = p;
  }
  return _impl_.errorcontext_;
}
inline ::com::htsc::mdc::insight::model::InsightErrorContext* LoginResponse::mutable_errorcontext() {
  ::com::htsc::mdc::insight::model::InsightErrorContext* _msg = _internal_mutable_errorcontext();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.LoginResponse.errorContext)
  return _msg;
}
inline void LoginResponse::set_allocated_errorcontext(::com::htsc::mdc::insight::model::InsightErrorContext* errorcontext) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.errorcontext_);
  }
  if (errorcontext) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(errorcontext));
    if (message_arena != submessage_arena) {
      errorcontext = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, errorcontext, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.errorcontext_ = errorcontext;
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.LoginResponse.errorContext)
}

// string token = 3;
inline void LoginResponse::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& LoginResponse::token() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.LoginResponse.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.LoginResponse.token)
}
inline std::string* LoginResponse::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.LoginResponse.token)
  return _s;
}
inline const std::string& LoginResponse::_internal_token() const {
  return _impl_.token_.Get();
}
inline void LoginResponse::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_token() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.LoginResponse.token)
  return _impl_.token_.Release();
}
inline void LoginResponse::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.LoginResponse.token)
}

// int64 lastLoginTime = 4;
inline void LoginResponse::clear_lastlogintime() {
  _impl_.lastlogintime_ = int64_t{0};
}
inline int64_t LoginResponse::_internal_lastlogintime() const {
  return _impl_.lastlogintime_;
}
inline int64_t LoginResponse::lastlogintime() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.LoginResponse.lastLoginTime)
  return _internal_lastlogintime();
}
inline void LoginResponse::_internal_set_lastlogintime(int64_t value) {
  
  _impl_.lastlogintime_ = value;
}
inline void LoginResponse::set_lastlogintime(int64_t value) {
  _internal_set_lastlogintime(value);
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.LoginResponse.lastLoginTime)
}

// string lastLoginIp = 5;
inline void LoginResponse::clear_lastloginip() {
  _impl_.lastloginip_.ClearToEmpty();
}
inline const std::string& LoginResponse::lastloginip() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.LoginResponse.lastLoginIp)
  return _internal_lastloginip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_lastloginip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lastloginip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.LoginResponse.lastLoginIp)
}
inline std::string* LoginResponse::mutable_lastloginip() {
  std::string* _s = _internal_mutable_lastloginip();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.LoginResponse.lastLoginIp)
  return _s;
}
inline const std::string& LoginResponse::_internal_lastloginip() const {
  return _impl_.lastloginip_.Get();
}
inline void LoginResponse::_internal_set_lastloginip(const std::string& value) {
  
  _impl_.lastloginip_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_lastloginip() {
  
  return _impl_.lastloginip_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_lastloginip() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.LoginResponse.lastLoginIp)
  return _impl_.lastloginip_.Release();
}
inline void LoginResponse::set_allocated_lastloginip(std::string* lastloginip) {
  if (lastloginip != nullptr) {
    
  } else {
    
  }
  _impl_.lastloginip_.SetAllocated(lastloginip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lastloginip_.IsDefault()) {
    _impl_.lastloginip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.LoginResponse.lastLoginIp)
}

// string reservedInfo = 6;
inline void LoginResponse::clear_reservedinfo() {
  _impl_.reservedinfo_.ClearToEmpty();
}
inline const std::string& LoginResponse::reservedinfo() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.LoginResponse.reservedInfo)
  return _internal_reservedinfo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_reservedinfo(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reservedinfo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.LoginResponse.reservedInfo)
}
inline std::string* LoginResponse::mutable_reservedinfo() {
  std::string* _s = _internal_mutable_reservedinfo();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.LoginResponse.reservedInfo)
  return _s;
}
inline const std::string& LoginResponse::_internal_reservedinfo() const {
  return _impl_.reservedinfo_.Get();
}
inline void LoginResponse::_internal_set_reservedinfo(const std::string& value) {
  
  _impl_.reservedinfo_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_reservedinfo() {
  
  return _impl_.reservedinfo_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_reservedinfo() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.LoginResponse.reservedInfo)
  return _impl_.reservedinfo_.Release();
}
inline void LoginResponse::set_allocated_reservedinfo(std::string* reservedinfo) {
  if (reservedinfo != nullptr) {
    
  } else {
    
  }
  _impl_.reservedinfo_.SetAllocated(reservedinfo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reservedinfo_.IsDefault()) {
    _impl_.reservedinfo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.LoginResponse.reservedInfo)
}

// string dataSource = 7;
inline void LoginResponse::clear_datasource() {
  _impl_.datasource_.ClearToEmpty();
}
inline const std::string& LoginResponse::datasource() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.LoginResponse.dataSource)
  return _internal_datasource();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_datasource(ArgT0&& arg0, ArgT... args) {
 
 _impl_.datasource_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.LoginResponse.dataSource)
}
inline std::string* LoginResponse::mutable_datasource() {
  std::string* _s = _internal_mutable_datasource();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.LoginResponse.dataSource)
  return _s;
}
inline const std::string& LoginResponse::_internal_datasource() const {
  return _impl_.datasource_.Get();
}
inline void LoginResponse::_internal_set_datasource(const std::string& value) {
  
  _impl_.datasource_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_datasource() {
  
  return _impl_.datasource_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_datasource() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.LoginResponse.dataSource)
  return _impl_.datasource_.Release();
}
inline void LoginResponse::set_allocated_datasource(std::string* datasource) {
  if (datasource != nullptr) {
    
  } else {
    
  }
  _impl_.datasource_.SetAllocated(datasource, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.datasource_.IsDefault()) {
    _impl_.datasource_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.LoginResponse.dataSource)
}

// string site = 8;
inline void LoginResponse::clear_site() {
  _impl_.site_.ClearToEmpty();
}
inline const std::string& LoginResponse::site() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.LoginResponse.site)
  return _internal_site();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_site(ArgT0&& arg0, ArgT... args) {
 
 _impl_.site_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.LoginResponse.site)
}
inline std::string* LoginResponse::mutable_site() {
  std::string* _s = _internal_mutable_site();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.LoginResponse.site)
  return _s;
}
inline const std::string& LoginResponse::_internal_site() const {
  return _impl_.site_.Get();
}
inline void LoginResponse::_internal_set_site(const std::string& value) {
  
  _impl_.site_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_site() {
  
  return _impl_.site_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_site() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.LoginResponse.site)
  return _impl_.site_.Release();
}
inline void LoginResponse::set_allocated_site(std::string* site) {
  if (site != nullptr) {
    
  } else {
    
  }
  _impl_.site_.SetAllocated(site, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.site_.IsDefault()) {
    _impl_.site_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.LoginResponse.site)
}

// .com.htsc.mdc.insight.model.ServiceDiscoveryResponse serviceDiscoveryResponse = 9;
inline bool LoginResponse::_internal_has_servicediscoveryresponse() const {
  return this != internal_default_instance() && _impl_.servicediscoveryresponse_ != nullptr;
}
inline bool LoginResponse::has_servicediscoveryresponse() const {
  return _internal_has_servicediscoveryresponse();
}
inline const ::com::htsc::mdc::insight::model::ServiceDiscoveryResponse& LoginResponse::_internal_servicediscoveryresponse() const {
  const ::com::htsc::mdc::insight::model::ServiceDiscoveryResponse* p = _impl_.servicediscoveryresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::htsc::mdc::insight::model::ServiceDiscoveryResponse&>(
      ::com::htsc::mdc::insight::model::_ServiceDiscoveryResponse_default_instance_);
}
inline const ::com::htsc::mdc::insight::model::ServiceDiscoveryResponse& LoginResponse::servicediscoveryresponse() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.LoginResponse.serviceDiscoveryResponse)
  return _internal_servicediscoveryresponse();
}
inline void LoginResponse::unsafe_arena_set_allocated_servicediscoveryresponse(
    ::com::htsc::mdc::insight::model::ServiceDiscoveryResponse* servicediscoveryresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.servicediscoveryresponse_);
  }
  _impl_.servicediscoveryresponse_ = servicediscoveryresponse;
  if (servicediscoveryresponse) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.htsc.mdc.insight.model.LoginResponse.serviceDiscoveryResponse)
}
inline ::com::htsc::mdc::insight::model::ServiceDiscoveryResponse* LoginResponse::release_servicediscoveryresponse() {
  
  ::com::htsc::mdc::insight::model::ServiceDiscoveryResponse* temp = _impl_.servicediscoveryresponse_;
  _impl_.servicediscoveryresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::com::htsc::mdc::insight::model::ServiceDiscoveryResponse* LoginResponse::unsafe_arena_release_servicediscoveryresponse() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.LoginResponse.serviceDiscoveryResponse)
  
  ::com::htsc::mdc::insight::model::ServiceDiscoveryResponse* temp = _impl_.servicediscoveryresponse_;
  _impl_.servicediscoveryresponse_ = nullptr;
  return temp;
}
inline ::com::htsc::mdc::insight::model::ServiceDiscoveryResponse* LoginResponse::_internal_mutable_servicediscoveryresponse() {
  
  if (_impl_.servicediscoveryresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::htsc::mdc::insight::model::ServiceDiscoveryResponse>(GetArenaForAllocation());
    _impl_.servicediscoveryresponse_ = p;
  }
  return _impl_.servicediscoveryresponse_;
}
inline ::com::htsc::mdc::insight::model::ServiceDiscoveryResponse* LoginResponse::mutable_servicediscoveryresponse() {
  ::com::htsc::mdc::insight::model::ServiceDiscoveryResponse* _msg = _internal_mutable_servicediscoveryresponse();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.LoginResponse.serviceDiscoveryResponse)
  return _msg;
}
inline void LoginResponse::set_allocated_servicediscoveryresponse(::com::htsc::mdc::insight::model::ServiceDiscoveryResponse* servicediscoveryresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.servicediscoveryresponse_);
  }
  if (servicediscoveryresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(servicediscoveryresponse));
    if (message_arena != submessage_arena) {
      servicediscoveryresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, servicediscoveryresponse, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.servicediscoveryresponse_ = servicediscoveryresponse;
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.LoginResponse.serviceDiscoveryResponse)
}

// .com.htsc.mdc.insight.model.AccountInfo accountInfo = 10;
inline bool LoginResponse::_internal_has_accountinfo() const {
  return this != internal_default_instance() && _impl_.accountinfo_ != nullptr;
}
inline bool LoginResponse::has_accountinfo() const {
  return _internal_has_accountinfo();
}
inline void LoginResponse::clear_accountinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.accountinfo_ != nullptr) {
    delete _impl_.accountinfo_;
  }
  _impl_.accountinfo_ = nullptr;
}
inline const ::com::htsc::mdc::insight::model::AccountInfo& LoginResponse::_internal_accountinfo() const {
  const ::com::htsc::mdc::insight::model::AccountInfo* p = _impl_.accountinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::com::htsc::mdc::insight::model::AccountInfo&>(
      ::com::htsc::mdc::insight::model::_AccountInfo_default_instance_);
}
inline const ::com::htsc::mdc::insight::model::AccountInfo& LoginResponse::accountinfo() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.LoginResponse.accountInfo)
  return _internal_accountinfo();
}
inline void LoginResponse::unsafe_arena_set_allocated_accountinfo(
    ::com::htsc::mdc::insight::model::AccountInfo* accountinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.accountinfo_);
  }
  _impl_.accountinfo_ = accountinfo;
  if (accountinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.htsc.mdc.insight.model.LoginResponse.accountInfo)
}
inline ::com::htsc::mdc::insight::model::AccountInfo* LoginResponse::release_accountinfo() {
  
  ::com::htsc::mdc::insight::model::AccountInfo* temp = _impl_.accountinfo_;
  _impl_.accountinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::com::htsc::mdc::insight::model::AccountInfo* LoginResponse::unsafe_arena_release_accountinfo() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.LoginResponse.accountInfo)
  
  ::com::htsc::mdc::insight::model::AccountInfo* temp = _impl_.accountinfo_;
  _impl_.accountinfo_ = nullptr;
  return temp;
}
inline ::com::htsc::mdc::insight::model::AccountInfo* LoginResponse::_internal_mutable_accountinfo() {
  
  if (_impl_.accountinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::com::htsc::mdc::insight::model::AccountInfo>(GetArenaForAllocation());
    _impl_.accountinfo_ = p;
  }
  return _impl_.accountinfo_;
}
inline ::com::htsc::mdc::insight::model::AccountInfo* LoginResponse::mutable_accountinfo() {
  ::com::htsc::mdc::insight::model::AccountInfo* _msg = _internal_mutable_accountinfo();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.LoginResponse.accountInfo)
  return _msg;
}
inline void LoginResponse::set_allocated_accountinfo(::com::htsc::mdc::insight::model::AccountInfo* accountinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.accountinfo_;
  }
  if (accountinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(accountinfo);
    if (message_arena != submessage_arena) {
      accountinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, accountinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.accountinfo_ = accountinfo;
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.LoginResponse.accountInfo)
}

// -------------------------------------------------------------------

// UserWithPassword

// string userName = 1;
inline void UserWithPassword::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& UserWithPassword::username() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.UserWithPassword.userName)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserWithPassword::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.UserWithPassword.userName)
}
inline std::string* UserWithPassword::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.UserWithPassword.userName)
  return _s;
}
inline const std::string& UserWithPassword::_internal_username() const {
  return _impl_.username_.Get();
}
inline void UserWithPassword::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* UserWithPassword::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* UserWithPassword::release_username() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.UserWithPassword.userName)
  return _impl_.username_.Release();
}
inline void UserWithPassword::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.UserWithPassword.userName)
}

// string password = 2;
inline void UserWithPassword::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& UserWithPassword::password() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.UserWithPassword.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserWithPassword::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.UserWithPassword.password)
}
inline std::string* UserWithPassword::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.UserWithPassword.password)
  return _s;
}
inline const std::string& UserWithPassword::_internal_password() const {
  return _impl_.password_.Get();
}
inline void UserWithPassword::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* UserWithPassword::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* UserWithPassword::release_password() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.UserWithPassword.password)
  return _impl_.password_.Release();
}
inline void UserWithPassword::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.UserWithPassword.password)
}

// string otp = 3;
inline void UserWithPassword::clear_otp() {
  _impl_.otp_.ClearToEmpty();
}
inline const std::string& UserWithPassword::otp() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.UserWithPassword.otp)
  return _internal_otp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserWithPassword::set_otp(ArgT0&& arg0, ArgT... args) {
 
 _impl_.otp_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.UserWithPassword.otp)
}
inline std::string* UserWithPassword::mutable_otp() {
  std::string* _s = _internal_mutable_otp();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.UserWithPassword.otp)
  return _s;
}
inline const std::string& UserWithPassword::_internal_otp() const {
  return _impl_.otp_.Get();
}
inline void UserWithPassword::_internal_set_otp(const std::string& value) {
  
  _impl_.otp_.Set(value, GetArenaForAllocation());
}
inline std::string* UserWithPassword::_internal_mutable_otp() {
  
  return _impl_.otp_.Mutable(GetArenaForAllocation());
}
inline std::string* UserWithPassword::release_otp() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.UserWithPassword.otp)
  return _impl_.otp_.Release();
}
inline void UserWithPassword::set_allocated_otp(std::string* otp) {
  if (otp != nullptr) {
    
  } else {
    
  }
  _impl_.otp_.SetAllocated(otp, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.otp_.IsDefault()) {
    _impl_.otp_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.UserWithPassword.otp)
}

// string captcha = 4;
inline void UserWithPassword::clear_captcha() {
  _impl_.captcha_.ClearToEmpty();
}
inline const std::string& UserWithPassword::captcha() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.UserWithPassword.captcha)
  return _internal_captcha();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserWithPassword::set_captcha(ArgT0&& arg0, ArgT... args) {
 
 _impl_.captcha_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.UserWithPassword.captcha)
}
inline std::string* UserWithPassword::mutable_captcha() {
  std::string* _s = _internal_mutable_captcha();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.UserWithPassword.captcha)
  return _s;
}
inline const std::string& UserWithPassword::_internal_captcha() const {
  return _impl_.captcha_.Get();
}
inline void UserWithPassword::_internal_set_captcha(const std::string& value) {
  
  _impl_.captcha_.Set(value, GetArenaForAllocation());
}
inline std::string* UserWithPassword::_internal_mutable_captcha() {
  
  return _impl_.captcha_.Mutable(GetArenaForAllocation());
}
inline std::string* UserWithPassword::release_captcha() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.UserWithPassword.captcha)
  return _impl_.captcha_.Release();
}
inline void UserWithPassword::set_allocated_captcha(std::string* captcha) {
  if (captcha != nullptr) {
    
  } else {
    
  }
  _impl_.captcha_.SetAllocated(captcha, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.captcha_.IsDefault()) {
    _impl_.captcha_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.UserWithPassword.captcha)
}

// string sms = 5;
inline void UserWithPassword::clear_sms() {
  _impl_.sms_.ClearToEmpty();
}
inline const std::string& UserWithPassword::sms() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.UserWithPassword.sms)
  return _internal_sms();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserWithPassword::set_sms(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sms_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.UserWithPassword.sms)
}
inline std::string* UserWithPassword::mutable_sms() {
  std::string* _s = _internal_mutable_sms();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.UserWithPassword.sms)
  return _s;
}
inline const std::string& UserWithPassword::_internal_sms() const {
  return _impl_.sms_.Get();
}
inline void UserWithPassword::_internal_set_sms(const std::string& value) {
  
  _impl_.sms_.Set(value, GetArenaForAllocation());
}
inline std::string* UserWithPassword::_internal_mutable_sms() {
  
  return _impl_.sms_.Mutable(GetArenaForAllocation());
}
inline std::string* UserWithPassword::release_sms() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.UserWithPassword.sms)
  return _impl_.sms_.Release();
}
inline void UserWithPassword::set_allocated_sms(std::string* sms) {
  if (sms != nullptr) {
    
  } else {
    
  }
  _impl_.sms_.SetAllocated(sms, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sms_.IsDefault()) {
    _impl_.sms_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.UserWithPassword.sms)
}

// -------------------------------------------------------------------

// UserWithToken

// string userName = 1;
inline void UserWithToken::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& UserWithToken::username() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.UserWithToken.userName)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserWithToken::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.UserWithToken.userName)
}
inline std::string* UserWithToken::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.UserWithToken.userName)
  return _s;
}
inline const std::string& UserWithToken::_internal_username() const {
  return _impl_.username_.Get();
}
inline void UserWithToken::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* UserWithToken::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* UserWithToken::release_username() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.UserWithToken.userName)
  return _impl_.username_.Release();
}
inline void UserWithToken::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.UserWithToken.userName)
}

// string token = 2;
inline void UserWithToken::clear_token() {
  _impl_.token_.ClearToEmpty();
}
inline const std::string& UserWithToken::token() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.UserWithToken.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserWithToken::set_token(ArgT0&& arg0, ArgT... args) {
 
 _impl_.token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.UserWithToken.token)
}
inline std::string* UserWithToken::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.UserWithToken.token)
  return _s;
}
inline const std::string& UserWithToken::_internal_token() const {
  return _impl_.token_.Get();
}
inline void UserWithToken::_internal_set_token(const std::string& value) {
  
  _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* UserWithToken::_internal_mutable_token() {
  
  return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* UserWithToken::release_token() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.UserWithToken.token)
  return _impl_.token_.Release();
}
inline void UserWithToken::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.UserWithToken.token)
}

// -------------------------------------------------------------------

// DeviceInfo

// string deviceId = 1;
inline void DeviceInfo::clear_deviceid() {
  _impl_.deviceid_.ClearToEmpty();
}
inline const std::string& DeviceInfo::deviceid() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.DeviceInfo.deviceId)
  return _internal_deviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_deviceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.deviceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.DeviceInfo.deviceId)
}
inline std::string* DeviceInfo::mutable_deviceid() {
  std::string* _s = _internal_mutable_deviceid();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.DeviceInfo.deviceId)
  return _s;
}
inline const std::string& DeviceInfo::_internal_deviceid() const {
  return _impl_.deviceid_.Get();
}
inline void DeviceInfo::_internal_set_deviceid(const std::string& value) {
  
  _impl_.deviceid_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_deviceid() {
  
  return _impl_.deviceid_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_deviceid() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.DeviceInfo.deviceId)
  return _impl_.deviceid_.Release();
}
inline void DeviceInfo::set_allocated_deviceid(std::string* deviceid) {
  if (deviceid != nullptr) {
    
  } else {
    
  }
  _impl_.deviceid_.SetAllocated(deviceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deviceid_.IsDefault()) {
    _impl_.deviceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.DeviceInfo.deviceId)
}

// string deviceMac = 2;
inline void DeviceInfo::clear_devicemac() {
  _impl_.devicemac_.ClearToEmpty();
}
inline const std::string& DeviceInfo::devicemac() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.DeviceInfo.deviceMac)
  return _internal_devicemac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_devicemac(ArgT0&& arg0, ArgT... args) {
 
 _impl_.devicemac_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.DeviceInfo.deviceMac)
}
inline std::string* DeviceInfo::mutable_devicemac() {
  std::string* _s = _internal_mutable_devicemac();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.DeviceInfo.deviceMac)
  return _s;
}
inline const std::string& DeviceInfo::_internal_devicemac() const {
  return _impl_.devicemac_.Get();
}
inline void DeviceInfo::_internal_set_devicemac(const std::string& value) {
  
  _impl_.devicemac_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_devicemac() {
  
  return _impl_.devicemac_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_devicemac() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.DeviceInfo.deviceMac)
  return _impl_.devicemac_.Release();
}
inline void DeviceInfo::set_allocated_devicemac(std::string* devicemac) {
  if (devicemac != nullptr) {
    
  } else {
    
  }
  _impl_.devicemac_.SetAllocated(devicemac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.devicemac_.IsDefault()) {
    _impl_.devicemac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.DeviceInfo.deviceMac)
}

// string deviceHarddisk = 3;
inline void DeviceInfo::clear_deviceharddisk() {
  _impl_.deviceharddisk_.ClearToEmpty();
}
inline const std::string& DeviceInfo::deviceharddisk() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.DeviceInfo.deviceHarddisk)
  return _internal_deviceharddisk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_deviceharddisk(ArgT0&& arg0, ArgT... args) {
 
 _impl_.deviceharddisk_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.DeviceInfo.deviceHarddisk)
}
inline std::string* DeviceInfo::mutable_deviceharddisk() {
  std::string* _s = _internal_mutable_deviceharddisk();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.DeviceInfo.deviceHarddisk)
  return _s;
}
inline const std::string& DeviceInfo::_internal_deviceharddisk() const {
  return _impl_.deviceharddisk_.Get();
}
inline void DeviceInfo::_internal_set_deviceharddisk(const std::string& value) {
  
  _impl_.deviceharddisk_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_deviceharddisk() {
  
  return _impl_.deviceharddisk_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_deviceharddisk() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.DeviceInfo.deviceHarddisk)
  return _impl_.deviceharddisk_.Release();
}
inline void DeviceInfo::set_allocated_deviceharddisk(std::string* deviceharddisk) {
  if (deviceharddisk != nullptr) {
    
  } else {
    
  }
  _impl_.deviceharddisk_.SetAllocated(deviceharddisk, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deviceharddisk_.IsDefault()) {
    _impl_.deviceharddisk_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.DeviceInfo.deviceHarddisk)
}

// string deviceCPU = 4;
inline void DeviceInfo::clear_devicecpu() {
  _impl_.devicecpu_.ClearToEmpty();
}
inline const std::string& DeviceInfo::devicecpu() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.DeviceInfo.deviceCPU)
  return _internal_devicecpu();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_devicecpu(ArgT0&& arg0, ArgT... args) {
 
 _impl_.devicecpu_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.DeviceInfo.deviceCPU)
}
inline std::string* DeviceInfo::mutable_devicecpu() {
  std::string* _s = _internal_mutable_devicecpu();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.DeviceInfo.deviceCPU)
  return _s;
}
inline const std::string& DeviceInfo::_internal_devicecpu() const {
  return _impl_.devicecpu_.Get();
}
inline void DeviceInfo::_internal_set_devicecpu(const std::string& value) {
  
  _impl_.devicecpu_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_devicecpu() {
  
  return _impl_.devicecpu_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_devicecpu() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.DeviceInfo.deviceCPU)
  return _impl_.devicecpu_.Release();
}
inline void DeviceInfo::set_allocated_devicecpu(std::string* devicecpu) {
  if (devicecpu != nullptr) {
    
  } else {
    
  }
  _impl_.devicecpu_.SetAllocated(devicecpu, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.devicecpu_.IsDefault()) {
    _impl_.devicecpu_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.DeviceInfo.deviceCPU)
}

// string cellphoneNumber = 5;
inline void DeviceInfo::clear_cellphonenumber() {
  _impl_.cellphonenumber_.ClearToEmpty();
}
inline const std::string& DeviceInfo::cellphonenumber() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.DeviceInfo.cellphoneNumber)
  return _internal_cellphonenumber();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_cellphonenumber(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cellphonenumber_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.DeviceInfo.cellphoneNumber)
}
inline std::string* DeviceInfo::mutable_cellphonenumber() {
  std::string* _s = _internal_mutable_cellphonenumber();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.DeviceInfo.cellphoneNumber)
  return _s;
}
inline const std::string& DeviceInfo::_internal_cellphonenumber() const {
  return _impl_.cellphonenumber_.Get();
}
inline void DeviceInfo::_internal_set_cellphonenumber(const std::string& value) {
  
  _impl_.cellphonenumber_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_cellphonenumber() {
  
  return _impl_.cellphonenumber_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_cellphonenumber() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.DeviceInfo.cellphoneNumber)
  return _impl_.cellphonenumber_.Release();
}
inline void DeviceInfo::set_allocated_cellphonenumber(std::string* cellphonenumber) {
  if (cellphonenumber != nullptr) {
    
  } else {
    
  }
  _impl_.cellphonenumber_.SetAllocated(cellphonenumber, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cellphonenumber_.IsDefault()) {
    _impl_.cellphonenumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.DeviceInfo.cellphoneNumber)
}

// string cellphoneImei = 6;
inline void DeviceInfo::clear_cellphoneimei() {
  _impl_.cellphoneimei_.ClearToEmpty();
}
inline const std::string& DeviceInfo::cellphoneimei() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.DeviceInfo.cellphoneImei)
  return _internal_cellphoneimei();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeviceInfo::set_cellphoneimei(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cellphoneimei_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.DeviceInfo.cellphoneImei)
}
inline std::string* DeviceInfo::mutable_cellphoneimei() {
  std::string* _s = _internal_mutable_cellphoneimei();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.DeviceInfo.cellphoneImei)
  return _s;
}
inline const std::string& DeviceInfo::_internal_cellphoneimei() const {
  return _impl_.cellphoneimei_.Get();
}
inline void DeviceInfo::_internal_set_cellphoneimei(const std::string& value) {
  
  _impl_.cellphoneimei_.Set(value, GetArenaForAllocation());
}
inline std::string* DeviceInfo::_internal_mutable_cellphoneimei() {
  
  return _impl_.cellphoneimei_.Mutable(GetArenaForAllocation());
}
inline std::string* DeviceInfo::release_cellphoneimei() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.DeviceInfo.cellphoneImei)
  return _impl_.cellphoneimei_.Release();
}
inline void DeviceInfo::set_allocated_cellphoneimei(std::string* cellphoneimei) {
  if (cellphoneimei != nullptr) {
    
  } else {
    
  }
  _impl_.cellphoneimei_.SetAllocated(cellphoneimei, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cellphoneimei_.IsDefault()) {
    _impl_.cellphoneimei_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.DeviceInfo.cellphoneImei)
}

// -------------------------------------------------------------------

// AccountInfo

// string userName = 1;
inline void AccountInfo::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& AccountInfo::username() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.AccountInfo.userName)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountInfo::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.AccountInfo.userName)
}
inline std::string* AccountInfo::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.AccountInfo.userName)
  return _s;
}
inline const std::string& AccountInfo::_internal_username() const {
  return _impl_.username_.Get();
}
inline void AccountInfo::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountInfo::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountInfo::release_username() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.AccountInfo.userName)
  return _impl_.username_.Release();
}
inline void AccountInfo::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.AccountInfo.userName)
}

// string startDate = 2;
inline void AccountInfo::clear_startdate() {
  _impl_.startdate_.ClearToEmpty();
}
inline const std::string& AccountInfo::startdate() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.AccountInfo.startDate)
  return _internal_startdate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountInfo::set_startdate(ArgT0&& arg0, ArgT... args) {
 
 _impl_.startdate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.AccountInfo.startDate)
}
inline std::string* AccountInfo::mutable_startdate() {
  std::string* _s = _internal_mutable_startdate();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.AccountInfo.startDate)
  return _s;
}
inline const std::string& AccountInfo::_internal_startdate() const {
  return _impl_.startdate_.Get();
}
inline void AccountInfo::_internal_set_startdate(const std::string& value) {
  
  _impl_.startdate_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountInfo::_internal_mutable_startdate() {
  
  return _impl_.startdate_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountInfo::release_startdate() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.AccountInfo.startDate)
  return _impl_.startdate_.Release();
}
inline void AccountInfo::set_allocated_startdate(std::string* startdate) {
  if (startdate != nullptr) {
    
  } else {
    
  }
  _impl_.startdate_.SetAllocated(startdate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.startdate_.IsDefault()) {
    _impl_.startdate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.AccountInfo.startDate)
}

// string stopDate = 3;
inline void AccountInfo::clear_stopdate() {
  _impl_.stopdate_.ClearToEmpty();
}
inline const std::string& AccountInfo::stopdate() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.AccountInfo.stopDate)
  return _internal_stopdate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountInfo::set_stopdate(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stopdate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.AccountInfo.stopDate)
}
inline std::string* AccountInfo::mutable_stopdate() {
  std::string* _s = _internal_mutable_stopdate();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.AccountInfo.stopDate)
  return _s;
}
inline const std::string& AccountInfo::_internal_stopdate() const {
  return _impl_.stopdate_.Get();
}
inline void AccountInfo::_internal_set_stopdate(const std::string& value) {
  
  _impl_.stopdate_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountInfo::_internal_mutable_stopdate() {
  
  return _impl_.stopdate_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountInfo::release_stopdate() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.AccountInfo.stopDate)
  return _impl_.stopdate_.Release();
}
inline void AccountInfo::set_allocated_stopdate(std::string* stopdate) {
  if (stopdate != nullptr) {
    
  } else {
    
  }
  _impl_.stopdate_.SetAllocated(stopdate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stopdate_.IsDefault()) {
    _impl_.stopdate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.AccountInfo.stopDate)
}

// string customerName = 4;
inline void AccountInfo::clear_customername() {
  _impl_.customername_.ClearToEmpty();
}
inline const std::string& AccountInfo::customername() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.AccountInfo.customerName)
  return _internal_customername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountInfo::set_customername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.customername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.AccountInfo.customerName)
}
inline std::string* AccountInfo::mutable_customername() {
  std::string* _s = _internal_mutable_customername();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.AccountInfo.customerName)
  return _s;
}
inline const std::string& AccountInfo::_internal_customername() const {
  return _impl_.customername_.Get();
}
inline void AccountInfo::_internal_set_customername(const std::string& value) {
  
  _impl_.customername_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountInfo::_internal_mutable_customername() {
  
  return _impl_.customername_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountInfo::release_customername() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.AccountInfo.customerName)
  return _impl_.customername_.Release();
}
inline void AccountInfo::set_allocated_customername(std::string* customername) {
  if (customername != nullptr) {
    
  } else {
    
  }
  _impl_.customername_.SetAllocated(customername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.customername_.IsDefault()) {
    _impl_.customername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.AccountInfo.customerName)
}

// string contactPerson = 5;
inline void AccountInfo::clear_contactperson() {
  _impl_.contactperson_.ClearToEmpty();
}
inline const std::string& AccountInfo::contactperson() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.AccountInfo.contactPerson)
  return _internal_contactperson();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountInfo::set_contactperson(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contactperson_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.AccountInfo.contactPerson)
}
inline std::string* AccountInfo::mutable_contactperson() {
  std::string* _s = _internal_mutable_contactperson();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.AccountInfo.contactPerson)
  return _s;
}
inline const std::string& AccountInfo::_internal_contactperson() const {
  return _impl_.contactperson_.Get();
}
inline void AccountInfo::_internal_set_contactperson(const std::string& value) {
  
  _impl_.contactperson_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountInfo::_internal_mutable_contactperson() {
  
  return _impl_.contactperson_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountInfo::release_contactperson() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.AccountInfo.contactPerson)
  return _impl_.contactperson_.Release();
}
inline void AccountInfo::set_allocated_contactperson(std::string* contactperson) {
  if (contactperson != nullptr) {
    
  } else {
    
  }
  _impl_.contactperson_.SetAllocated(contactperson, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contactperson_.IsDefault()) {
    _impl_.contactperson_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.AccountInfo.contactPerson)
}

// string contactAddress = 6;
inline void AccountInfo::clear_contactaddress() {
  _impl_.contactaddress_.ClearToEmpty();
}
inline const std::string& AccountInfo::contactaddress() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.AccountInfo.contactAddress)
  return _internal_contactaddress();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountInfo::set_contactaddress(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contactaddress_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.AccountInfo.contactAddress)
}
inline std::string* AccountInfo::mutable_contactaddress() {
  std::string* _s = _internal_mutable_contactaddress();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.AccountInfo.contactAddress)
  return _s;
}
inline const std::string& AccountInfo::_internal_contactaddress() const {
  return _impl_.contactaddress_.Get();
}
inline void AccountInfo::_internal_set_contactaddress(const std::string& value) {
  
  _impl_.contactaddress_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountInfo::_internal_mutable_contactaddress() {
  
  return _impl_.contactaddress_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountInfo::release_contactaddress() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.AccountInfo.contactAddress)
  return _impl_.contactaddress_.Release();
}
inline void AccountInfo::set_allocated_contactaddress(std::string* contactaddress) {
  if (contactaddress != nullptr) {
    
  } else {
    
  }
  _impl_.contactaddress_.SetAllocated(contactaddress, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contactaddress_.IsDefault()) {
    _impl_.contactaddress_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.AccountInfo.contactAddress)
}

// string contactTel = 7;
inline void AccountInfo::clear_contacttel() {
  _impl_.contacttel_.ClearToEmpty();
}
inline const std::string& AccountInfo::contacttel() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.AccountInfo.contactTel)
  return _internal_contacttel();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountInfo::set_contacttel(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contacttel_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.AccountInfo.contactTel)
}
inline std::string* AccountInfo::mutable_contacttel() {
  std::string* _s = _internal_mutable_contacttel();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.AccountInfo.contactTel)
  return _s;
}
inline const std::string& AccountInfo::_internal_contacttel() const {
  return _impl_.contacttel_.Get();
}
inline void AccountInfo::_internal_set_contacttel(const std::string& value) {
  
  _impl_.contacttel_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountInfo::_internal_mutable_contacttel() {
  
  return _impl_.contacttel_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountInfo::release_contacttel() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.AccountInfo.contactTel)
  return _impl_.contacttel_.Release();
}
inline void AccountInfo::set_allocated_contacttel(std::string* contacttel) {
  if (contacttel != nullptr) {
    
  } else {
    
  }
  _impl_.contacttel_.SetAllocated(contacttel, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contacttel_.IsDefault()) {
    _impl_.contacttel_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.AccountInfo.contactTel)
}

// string contactEmail = 8;
inline void AccountInfo::clear_contactemail() {
  _impl_.contactemail_.ClearToEmpty();
}
inline const std::string& AccountInfo::contactemail() const {
  // @@protoc_insertion_point(field_get:com.htsc.mdc.insight.model.AccountInfo.contactEmail)
  return _internal_contactemail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountInfo::set_contactemail(ArgT0&& arg0, ArgT... args) {
 
 _impl_.contactemail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.htsc.mdc.insight.model.AccountInfo.contactEmail)
}
inline std::string* AccountInfo::mutable_contactemail() {
  std::string* _s = _internal_mutable_contactemail();
  // @@protoc_insertion_point(field_mutable:com.htsc.mdc.insight.model.AccountInfo.contactEmail)
  return _s;
}
inline const std::string& AccountInfo::_internal_contactemail() const {
  return _impl_.contactemail_.Get();
}
inline void AccountInfo::_internal_set_contactemail(const std::string& value) {
  
  _impl_.contactemail_.Set(value, GetArenaForAllocation());
}
inline std::string* AccountInfo::_internal_mutable_contactemail() {
  
  return _impl_.contactemail_.Mutable(GetArenaForAllocation());
}
inline std::string* AccountInfo::release_contactemail() {
  // @@protoc_insertion_point(field_release:com.htsc.mdc.insight.model.AccountInfo.contactEmail)
  return _impl_.contactemail_.Release();
}
inline void AccountInfo::set_allocated_contactemail(std::string* contactemail) {
  if (contactemail != nullptr) {
    
  } else {
    
  }
  _impl_.contactemail_.SetAllocated(contactemail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.contactemail_.IsDefault()) {
    _impl_.contactemail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.htsc.mdc.insight.model.AccountInfo.contactEmail)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace model
}  // namespace insight
}  // namespace mdc
}  // namespace htsc
}  // namespace com

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::com::htsc::mdc::insight::model::ELoginType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::htsc::mdc::insight::model::ELoginType>() {
  return ::com::htsc::mdc::insight::model::ELoginType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Login_2eproto
